# 2. JVM 이야기
- 성능에 관심이 있는 개발자라면 기본적인 jvm 기술 스택을 이해해야합니다.
## 2.1 인터프리팅과 클래스로딩
- 자바 가상 머신을 규정한 명세서에 따르면 jvm은 스택 기반의 해석머신 (물리적 레지스터는 없지만 실행스택에 보관하여 계산합니다.)
- JVM의 인터프리터의 기본 로직은, 중간 값을 담아두고 가장 마지막에 실행된 명령어와 프로그램을 구성하는 옵코드를 하나씩 처리하는 'WHILE 루프안의 OPCODE'
- JAVA 실행시에는, 
  - 1. 가상 머신 프로세스(자바 바이너리)를 ㅅ구동
  - 2. 자바 가상 환경 구성
  - 3. 스택 머신이 초기화된 다음, HelloWorld 클래스 파일 실행
  - 4. 진입점, Helloworld.class 에 있는 main() 메서드
  - 5. 가상 머신 실행 전에 클래스를 로드한다.
    - a. 부트스트랩 클래스 -> 자바 런타임 코어 클래스 로드 (최소한의 필수 클래스 로드: java.lang.Object, Class, Classloader)
    - b. 확장 클래스로더 -> 부트스트랩 클래스로더를 부모로 설정하고 로딩(특정한 os 나 플랫폼 네이티브 코드)
    - c. 애플리케이션 클래스로더 생성, 지정된 클래스패스에 유저클래스 로드
    - d. 새 클래스는 디펜던시에 로드 (클래스로더에 룩업 넘김) -> 없으면 ClassNotFoundException
    - e. 한 클래스는 풀클래스명, 자신을 로드한 클래스로드로 식별 (이중 로딩 방지)

## 2.2 바이트 코드 실행
- 자바 컴파일러 javc를 이용해 컴파일 하는것
- 1. javac 컴파일 ->  자바 소스코드를 바이트코드 형태 .class로 변경
- 2. javap( 역어셈블리툴)로 열어보면 자바 코드 어렵잖게 알아 볼 수 있ㅇ므
- 3. 바이트 코드는 특정 컴퓨터 아키텍쳐에 특정핮 ㅣ않은 중간 표현형(jvm지원 플랫폼 어디든 실행 가능하다.)
- 4. 클래스 해부도
  - a. 매직넘버
  - b. 클래스 파일 포맷 버전
  - c. 상수 풀
  - d. 액세스 플래그
  - e. this 클래스
  - f. 슈퍼클래스
  - g. 인터페이스
  - h. 필드
  - i. 메서드
  - j. 속성 (소스파일명)
-
## 2.3 핫스팟 입문
- c++는 제로 오버헤드 원칙입니다. -> 아주 세세한 저서준 까지 명시해야함
- 핫스팟은 런타임 동작을 분석하고 성능에 가장 유리한 방향으로 영리한 최적화를 적용하는 가상 머신입니다.

## 2.4 JIT 컴파일이란
- 자바 프로그램은 바이트코드 인터프리터가 가상화한 스택 머신에서 명령어를 실행하며 시작된다.
- 프로그램 단위(메서드와 루프)를 인터프리티드 바이트 코드에서 네이티브 코드로 컴파일 합니다. -> jit 컴파일이라고 부릅니다.
- 애플리케이션을 모니터링 하면서 가장 자주 실행하는 코드 파틀르 발견해서 jit 컴파일으로 수행합니다. 10장
- 특정 메서드가 어느 한계치를 넘어가면 프로파일러가 특정 코드 섹션을 컴파일/최적화 합니다.
- 컴파일러 해석 단계에서 수집한 추적정보를 근거로 최적화를 결정 합니다.
- 자바에서는 PGO(Profile guided Optimization)을 으용해서 런타임 정보를 동적 인라이닝, 가상호출로 성능을 개선할 수 있습니다. 9장
- 핫스팟 vm은 시동시 cpu 타입을 정확히 감지해서 특정 프로세서의 기능에 맞게 최적화 적용할 수 있습니다. 
## 2.5 JVM 메모리 관리
- 자바는 가비지 수집이라는 프로세스를 이용해 힙 메모리를 자동 관리하는 방식 해결합니다.
- jvm이 더 많은 메모리를 할당 해야할 때 불필요한 메모리를 회수하거나 재사용하는 불확정적 프로세스 입니다.

## 2.6 스레딩과 자바 메모리 모델(JMM)
- JVM처럼 멀티스레드 기반인 깓락에 자바프로그램이 작동하는 방식은 복잡하고 분석하기 힘들어졌습니다.
- 하나의 전용 OS스레드에 정확히 하나의 자바 에플리케이션 스레드가 대응됩니다.
- JAVA 멀티스레드 방식은 세가지 원칙에 기반합니다
  - 자바의 프로세스의 모든 스레드는 가비지가 수집되는 하나의 공용 힙을 가진다.
  - 한 스레드가 생성한 객체는 그 객체를 참조하는 다른 스레드가 액세스 할 수 있다.
  - 객체는 변경 가능하다. FINAL이 아닐시 바뀔 수 있다.
  - 상호 배타적 락은 코드가 동시 실행되는중 객체가 손상되는 현상을 막을 수 있습니다. JMM의 원리와 스레드 락을 다루는 방법은 12장에서 다룹니다.
## 2.7 JVM 구현체 종류
  - OPENJDK
  - Oracle
## 2.8 JVM 모니터링과 툴링
  - JMX (Java Management Extension)
  - Java Agent
  - jvm에 동작하는 애플리케이션을 제어하고 모니터링하는 강력한 범용 툴입니다.
## 2.8.1 VisualVm
  - 자바 프로세스 모니터링툴


