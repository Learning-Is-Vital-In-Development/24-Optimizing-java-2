# 2장. JVM 이야기

JVM이 자바 코드를 실행하는 방법

## 2.1 인터프리팅과 클래스로딩

JVM은 스택기반의 해석 머신이다.

그래서 일부 결과들을 실행 스택에 보관하며, 이 스택의 맨위부터 쌓인 값들을 가져와 계산하게 된다.

JVM 인터프리터의 기본 로직은 while루프 안의 switch문이라고 생각하면 쉽다.

자바 파일을 실행하게 되면 OS는 가상 머신 프로세스인 자바 바이너리를 구동한다.

자바 가상 환경이 구성되고 스택 머신이 초기화된 이후 클래스 파일이 실행되는 구조로 되어있다.

항상 애플리케이션의 진입점은 `main()` 메소드다.

제어권을 구현한 클래스로 넘기고 싶다면 가상 머신이 실행되기 이전에 이 클래스를 로드시켜야 한다.

→ 이 때, 자바 클래스로딩이 실행된다.

자바 프로세스가 새로 초기화 되면 클래스 로더가 차례대로 동작한다.

### 1. 부트스트랩 클래스

가장 먼저 동작하며 자바 런타임 코어 클래스를 로드한다.

자바8이전까지는 `rt.jar` 에서 가져왔지만 자바9 버전부터는 런타임이 모듈화되고 클래스로딩 개념 자체가 달라졌다.

최소한의 `java.lang.Object` , Class, ClassLoader 만 로드한다.

### 2. 확장 클래스 로더

부트스트랩 클래스로더를 자기 부모로 설정 후 필요한 작업이 있는 경우 클래스 로딩작업을 부트스트랩한테 넘긴다.

특정 OS나 플랫폼에 native code를 제공 및 기본 환경 재정의가 가능하다.

### 3. 애플리케이션 클래스 로더

지정된 classpath에 위치한 유저 클래스를 로드한다.

프로그램 실행 중 처음보는 클래스는 자신의 부모 클래스로더에게 위임하고, 찾아보는 기능을 넘긴다.

이 때도 찾지 못하면 계속해서 위의 부모로 올라가게 된다.

이 상태에서 부트스트랩까지 찾지 못한다면 `ClassNotFoundException` 이 실행된다.

보통환경에서 자바는 클래스를 로드할 때 런타임 환경에서 Class객체를 만드는데, 같은 클래스를 여러번 다른 클래스로더가 n회 로드할 수 있다.

한 시스템에서 클래스는 풀 클래스명과 자신을 로드한 클래스로더 이 두가지 정보로 식별한다.

## 2.2 바이트코드 실행

### 1. javac

javac을 이용해 컴파일을 수행한다.

javac이 하는 일은 자바 소스코드를 바이트코드 `.class` 파일로 변환해주는 것

javac은 컴파일 하는동안 최적화를 많이 하지 않기 때문에 쉽게 해독이 가능하다.

바이트코드는 특정 컴퓨터 아키텍처에 특정되지 않은 중간 표현형이다.

JVM이 설치되어 있는 소프트웨어라면 이식성이 좋아서 어디서든 실행이 가능하다.

모든 클래스파일은 `0xCAFEBEBE` 라는 매직넘버로 이 파일이 클래스파일임을 나타내는 4바이트 16진수로 시작한다.

그 다음 4바이트는 컴파일 시 메이저/마이너 버전의 숫자이다

클래스 로더의 호환성 보장을 위해 검사하고 호환되지 않는다면 `UnsupportedClassVersionError` 가 난다.

> 상수 풀
>

클래스명, 인터페이스명, 필드명 등등의 상수값이 존재한다.

JVM은 코드를 실행할 때 런타임에 배치된 메모리 대신, 상수 테이블을 찾아보고 필요한 값을 참조한다.

> 액세스 플래그
>

클래스에 적용한 수정자 결정.

첫 부분은 일반 프로퍼티며, public 클래스인지 final 클래스인지 나타냄.

클래스 유형도 이 플래그로 표시한다.

플래그 끝에는 클래스 파일이 합성 클래스인지 다른 타입인지 나타냄.

this, 슈퍼, 인터페이스 엔트리는 클래스에 포함된 타입계층을 나타냄.

상수풀을 가리키는 인덱스로 표시한다.

![스크린샷 2024-01-14 오후 11 03 02](https://github.com/Learning-Is-Vital-In-Development/24-optimizing-java-2/assets/74235102/28ba861e-5e00-4201-9c35-c0c02234151d)


## 2.3 핫스팟 입문

썬 마이크로시스템즈가 성능 관점에서 자바에 가장 큰 변화를 가져왔다.

여기서 핫스팟 가상머신이 나온다.

![스크린샷 2024-01-14 오후 11 06 07](https://github.com/Learning-Is-Vital-In-Development/24-optimizing-java-2/assets/74235102/b3bd3042-2c81-4fa5-b21b-9d4c32d1a3d6)


제로-오버헤드를 위해 C언어 같은 언어들은 소스코드를 빌드하면 플랫폼에 특정한 기계어로 컴파일된다. → AOT(Ahead Of Time) 컴파일이라고 한다.

핫스팟 VM은 개발자가 억지로 VM에 맞게 프로그램을 욱여넣는대신 자바 코드를 자연스레 작성하고 바람직한 설계원리를 따르도록 하는 것이다.

## JIT 컴파일이란?

자바 프로그램은 바이트코드 인터프리터가 가상화한 스택 머신에서 명령어를 실행하며 시작된다.

CPU를 추상화했기에 다른 플랫폼에서도 클래스 파일을 문제없이 실행할 수 있지만, 성능을 최대치로 내기 위해서는 네이티브 기능을 활용해 CPU에서 직접 프로그램을 실행시켜주어야 한다.

핫스팟이 여기서 프로그램 단위를 인터프리터 바이트코드에서 네이티브 코드로 컴파일하는데, 이를 JIT(Just In Time) 컴파일이라고 한다.

인터프리티드 모드로 실행하는 동안 애플리케이션에 대한 모니터링을 수행하며 가장 자주 실행되는 코드 부분을 JIT 컴파일 수행한다.

자바처럼 프로필 기반 최적화를 하는 환경에선 동적 인라이닝 또는 가상 호출로 성능을 개선할 수 있다.

핫스팟VM은 시동 시 CPU 타입을 정확히 감지하여 특정 프로세서의 기능에 맞게 최적화를 적용할 수 있다.

## JVM 메모리 관리

자바는 가비지 수집이라는 프로세스를 이용해 힙 메모리를 자동 관리하는 방식으로 해결한다.

## 스레딩과 자바 메모리 모델

자바는 1.0 버전부터 멀티스레드 프로그래밍을 기본적으로 지원했다.

자바 애플리케이션 스레드는 하나의 전용 OS 스레드에 대응된다.

공유 스레드 풀을 이용해서 전체 자바 애플리케이션 스레드를 실행하는 그린스레드도 있지만, 만족할 성능은 나오지 않았다.

### 자바의 멀티스레드 방식

- 자바 프로세스의 모든 스레드는 가비지가 수집되는 하나의 공용 힙을 가진다.
- 한 스레드가 생성한 객체는 그 객체를 참조하는 다른 스레드가 액세스 할 수 있다.
- 기본적으로 객체는 변경 가능하다. 즉, 객체 필드에 할당된 값은 프로그래머가 애써 final 키워드로 불변표시하지 않는 한 바뀔 수 있다.

## JVM 구현체 종류

### OpenJDK

자바 기준 구현체를 제공하는 오픈소스.

오라클이 직업 프로젝트 주관하며 자바 릴리즈 기준을 발표한다.

### OracleJDK

가장 널리 알려진 구현체, OpenJDK 기반이지만 오라클 상용 라이선스로 재 라이선스를 받음.

### Zulu

Azul 시스템이 제작한 무료 OpenJDK 구현체

### IcedTea

레드햇의 작품. 풀 인증 받음.

### Zing

Azul 시스템이 제작한 고성능 상용 JVM

64bit Linux에서만 작동한다. 대용량 힙메모리와 멀티 CPU서버급 시스템을 위해 설계된 제품이다.

### ETC

J9, Avian, Android 등이 있다.

## JVM 모니터링과 툴링

### JMX

JVM과 그 위에서 동작하는 애플리케이션을 제어하고 모니터링하는 툴

클라이언트 애플리케이션처럼 메소드를 호출하고 매개변수를 바꿀 수 있다.

### Javaagent

자바 언어로 작성된 툴 컴포넌트, `java.lang.instrument` 인터페이스로 메소드 바이트코드를 조작한다.

`-javaagent:<에이전트 JAR파일 경로>=<옵션>`

manifest.mf 파일은 에이전트 JAR파일에서 필수이다.

`PremainClass` 속성에 클래스명을 반드시 지정해야함.

### SA

자바 객체, 핫스팟 자료구조 모두 표출 가능한 API와 툴을 모아놓은 것.

### VisualVM

JVM 어태치 메커니즘을 통해 실행 프로세스를 실시간 모니터링한다.

> 개요
>

자바 프로세스에 관한 요약 정보를 표시.

프로세스에 전달한 전체 플래그와 시스템 프로퍼티, 실행중인 자바 버전 표기

> 모니터
>

CPU, Heap 사용량 등 JVM 을 고수준에서 원격 측정한 값들이 표시된다.

> 스레드
>

실행중인 애플리케이션 각 스레드가 시간대별로 표시된다.

스레드별 상태와 변화들을 보며 스레드덤프를 뜰 수 있다.
