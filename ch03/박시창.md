# 3. 하드웨어와 운영체제

## 3.1 최신 하드웨어 소개
## 3.2 메모리
- 프로세서 코어의 데이터 수요를 메인 메모리가 맞추기 어려웠다.
- 클록 속도가 올라가도 cpu는 메모리가 도착할때까지 놀았다.
- cpu 캐시가 고안되서 L1, L2 가 사본을 떠서 보관한다.
- MESI에 따라 상태가 변경되며 무효화 브로드캐스팅을 합니다.
- 초기 프로세서는 매번 캐시 연산결과를 메모리에 기록 -> WRITE-THROUGH -> 메모리 대역폭을 너무 많이 소모, 효율 낮음
- 후기 프로세서는 WRITE-BACK을 채택해서 캐시 블록을 교체해도 DIRTY 캐시 블록만 메모리에 기록해서 메모리 기록의 비율이 낮습니다.
- 캐시 기술로 최대 전송률을 높일 수 있습니다.
  - 메모리 클록 주파수
  - 메모리 버스폭
  - 인터페이스 개수

## 3.3 최신 프로세서의 특성
- 변환 색인 버퍼(TLB)
  - 가상 메모리 주소를 물리 메모리 주소로 매핑하는 페이지 테이블의 캐시역할을 수행한다.
  - 가상 주소를 참조해 물리주소 액세스가 쉽다.
  - TLB가 없으면 L1캐시에 페이지 테이블이 있어도 16사이클이 걸린다
- 분기 예측과 추측 실행
  - 분기 예측은 조건 분기에 대한 기준값 평가하느라 대기하는것을 미리 예상하고 실행후에 아니라면 파이프라인을 제거합니다.
    - 보안문제가 있었ㅇ므 2018년
- 하드웨어 메모리 모델
- 서로 다른 CPU가 일관데게 동일한 메모리 주소를 액세스 할 수 있을까?
  - 코드 실행순서를 바꿀수있다. -> 현재 스레드가 바라보는 결과에 아무런 영향이 없다는 전제가 잇다면
## 3.4 운영체제
- OS의 주 임무는 여러 실행 프로세스가 공유하는 리소스 액세스를 관장하는 일
- 메모리 관리 유닛(MMU)를 통한 가상 주소 방식과 페이지 테이블은 메모리 엑세스 제어의 핵심으로 한 프로세스가 소유한 메모리 영역을 다른 프로세스가 함부로 훼손 못함
- TLB는 물리 메모리 룩업시간을 줄임
- MMU는 굉장히 저수준이라서 OS 액세스 스케줄러를 살펴보자 

## 3.5 스케줄러
- 프로세스 스케줄러는 CPU 액세스를 토제
- 실행 큐를 이용한다.
- OS 스케줄링은 10%, 20%의 오버헤드를 발생시킨다. WAIT, SLEEP 같은 I/O, 소프트웨어 인터럽트나 코어 액세스를 관리합니다.
- 타이밍은 성능 측정, 프로세스 스케줄링에 중요합니다.
## 3.6 컨텍스트 교환
- CONTEXT SWITCH는 OS 스케줄러가 현재 실행 중인 스레드/태스크를 없애고 대기 중인 다른 스레드/태스크로 대체하는 프로세스입니다.
- 유저모드 -> 커널모드 -> 컨텍스트 모드가 생기고 TLB, 다른 캐시까지 무효화가 됩니다.
- 이를 만회하려고 Vdso 같은 특권이 필요없는 유저 공간의 메모리 영역을 생성했습니다.

## 3.6 단순 시스템 모델
- 자바 애플리케이션의 구조
  - 애플리케이션이 실행되는 하드웨어 os
  - 애플리케이션이 실행되는 jvm, 컨테이너
  - 애플리케이션 코드 자체
  - 애플리케이션 호출하는 외부 시스템
  - 애플리케이션에 유입되는 트래픽

### 3.6.1 cpu 사용률
  - cpu 사용률은 애플리케이션 성능을 나타낸는 핵심 지표입니다.
  - 부하중에 가능한한 100%에 가까워야합니다.
  - vmstat으로 
    - proc ->  r, b 프로세스 갯수
    - memory -> swap 메모리, 비사용 메모리, 버퍼로 사용한 메모리, 캐시로 사용한 메모리
    - swap -> 디스크가 교체되어 들어간 메모리, 디스크가 교체되어 빠져나온 메모리
    - system 섹션 -> 인터럽트 및 초당 컨텍스트 교환 횟수입니다.
    - cpu 섹션: 유저시간, 커널시간, 유휴시간, 대기시간, 도둑맞은 시간 표기합니다.
  - CPU 사용률이 100%을 치지않으면 왜 그럴까를 따져야합니다
    - 락때문에 발생한 컨텍스트 교환인가?
    - IO경합이 일어나 블로킹이 발생햇나?
  - VMSTAT에서 컨텍스트 교환 비율이 높게 나타나면 IO에서 블로킹이 일어났거나, 스레드 락 경합 상황이 벌어졌을 공산이 큽니다.
### 3.6.2 가비지 수집
  - 핫스팟 JVM은 시작시 메모리를 유저 공간에 할당합니다.
  - JVM 프로세스가 유저공간에서 CPU를 100%을 치면 GC를 의심해야합니다.
  - 커널에서는 GC하지않음
  - JVM에서 유저공간의 CPU사용률이 높은건 거의 GC 서브시스템 탓입니다.
  - GC로깅은 분석용 데이터의 원천으로 가치가 높아서 운영환경에서는 꼭 남겨야합니다.
### 3.6.3 입출력
  - 파일 I/O는 예로부터 전체 시스템 성능에 암적인 존재였습니다.
  - 메모리에는 가상 메모리라는 우아한 격리 장치가 있지만, I/O는 개발자가 추상화할 장칙 ㅏ없습니다.
  - IOSTAT으로 기본카운터를 진단하기에 더할 나위 없이 좋습니다.
### 커널 바이패스 I/O
  - 커널을 이용해 데이터를 복사해 유저공간에 넣는 작업이 상당히 비싼 고성능 애플리케이션이 있다.
  - 이러한 경우 커널 대신 네트워크 카드에 직접 데이터를 매핑하는 전용 하드웨어/소프트웨어를 사용합니다.

### 가상화
  - 가상화 오버헤드 작아야한다.
### 3.8 
  - 스레드 스케줄링 같은 서비스를 OS에 액세스 해야한다.
  - 이런기능은 JNI라는 네이티브 메서드로 구현됩니다.

