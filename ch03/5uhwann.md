# Ch3. 하드웨어와 운영체제

## 메모리
### CPU 캐시
- CPU에 있는 메모리 영역
- 레지스터보다는 느리지만 메인 메모리보다는 빠름
- 자주 엑세스하는 메모리 위치는 CPU가 메인 메모리를 재참조 하지 않게 사본을 CPU 캐시에 보관
- 각 코어별 L1, L2 캐시, 모든 코어가 공유하는 클로벌 L3 캐시를 두어 최적화

## 운영체제
- 여러 실행 프로세스가 공유하는 리소스 엑세스를 관장(주로 메모리, CPU)

### 스케줄러
- 프로세스 스케줄러는 CPU 엑세스를 통제, 실행 큐 이용
- OS는 특성상 CPU에서 코드가 실행되지 않는 시간을 유발, 따라서 실제 관측한 프로세스에서 나온 통계치는 다른 프로세스의 동작에도 영향을 받음 -> 측정 결과에 노이즈 생성
- 스케줄러의 움직임을 확인하는 가장 쉬운 방법은 OS 스케줄링 과정에서 발생시킨 오버헤드를 관측하는 것

### 시간 문제
- OS는 저마다 타이밍이 다르게 작동한다.

### 컨텍스트 교환
- OS 스케줄러가 현재 실행 중인 스레드/태스크를 없애고 대기 중인 다른 스레드/태스크로 대체하는 프로세스
- 스레드 실행 명령과 스택 상태를 교체하는 모든일에 연관
- 유저 모드에서 커널 모드로의 교환 시 모든 OS의 모든 캐시가 무효화 되어 시스템 콜에 대한 비용이 가려짐
  - 리눅스는 가상 동적 공유 객체(vDSO)를 통해 시스템 콜의 속도를 높여 커널 모드로 컨텍스트 교환을 하지 않음

## 기본 감지 전략
### CPU 사용률
- CPU 사용률은 어플리케이션 성능을 나타내는 핵심 지표
- CPU 효율성 상승은 성능 향상의 지름길
- 어플리케이션 성능 분석 시에는 시스템에 충분한 부하를 가해 사용률을 간능한 한 100%에 가까워야 한다.
- `vmstat`
  - proc: 실행 가능(r) 블로킹된(b) 프로세스 개수 나타냄
  - memory: 스왑 메모리(swpd), 미사용 메모리(free), 버퍼 사용 메모리(buff), 캐시 메모리(cache)
  - cpu: 유저 시간(us), 커널 시간(sy), 유휴 시간(id), 대기 시간(wa), 도둑맞은 시간(st 가상 머신에 할애)에 대한 사용율 표기
  - swap, io,, system
- 성능 측정 결과 CPU 사용률이 100%에 근접하지 않았다면 그 원인을 따져봐야 한다.

## 가비지 수집
- GC는 유저 공간의 CPU 사이클을 소비하되 커널 공간의 사용률에는 영향을 미치지 않기 때문에, JVM 프로세스가 유저 공간에서 CPU를 100%에 가깝게 사용한다면, GC를 의심해야 한다.
- GC 로깅은 데이터의 원천으로서의 가치가 높기 때문에 JVM 프로세스는 예외없이 GC로그를 남겨야 한다.
