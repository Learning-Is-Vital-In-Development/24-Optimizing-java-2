# 3장. 하드웨어와 운영체제

# 메모리

CPU 프로세서 코어 클럭 속도가 증가하니 메인 메모리를 맞추기 어려웠다.

## 메모리 캐시

CPU 캐시가 고안됐고, CPU 캐시는 CPU 내에 있는 메모리 영역이다.

액세스 빈도가 높은 캐시일수록 프로세서 코어와 더 가까이 위치하게 여러 캐시계층이 존재한다.

- L1 캐시
    - CPU와 가장 가까운 캐시
- L2 캐시
- …

각 실행코어에 L1, L2 전용 프라이빗 캐시를 두고, 일부나 전체가 공유하는 L3 캐시를 둔다.

캐시라는 아키텍처를 추가하여 프로세서 처리율은 개선했지만. 메모리 데이터를 캐시로 어떻게 가져오고, 갱신은 어떻게 하는지를 결정해야 했다.

이 문제는 `캐시 일관성 프로토콜` 이라는 방법으로 해결한다.

> MESI프로토콜
>
- Modified(수정)
    - 데이터가 수정된 상태
- Exclusive(배타)
    - 이 캐시에만 존재하고 메인 메모리 내용과 동일한 상태
- Shared(공유)
    - 둘 이상의 캐시에 데이터가 들어있고 메모리 내용과 동일한 상태
- Invalid(무효)
    - 다른 프로세스가 데이터를 수정하여 무효한 상태

캐시기술덕에 데이터를 메모리에서 쓰고 읽을 수 있게 됐다.

이론상 가능한 최대 전송률은 아래 인자들에 따라 달라진다.

- 메모리 클록 주파수
- 메모리 버스 폭(보통 64비트)
- 인터페이스 개수(대부분 2개)

## 최신 프로세스의 특성

### 변환 색인 버퍼(Translation Lookaside Buffer)

캐시에서 아주 요긴하게 쓰이는 장치

가상 메모리 주소를 물리 메모리 주소로 매핑하는 페이지 테이블의 캐시 역할

### 분기 예측과 추측 실행

분기 예측은 고급 기법중 1개로 프로세서가 조건 분기하는 기준값을 평가하느라 대기하는 현상을 방지한다.

# 운영체제

여러 실행 프로세스가 공유하는 리소스 액세스를 관장하는 일

메모리 관리 유닛을 통한 가상 주소방식과 페이지 테이블은 메모리 액세스 제어의 핵심이며, 한 프로세스가 소유한 영역을 다른 프로세스가 함부로 훼손하지 못하게한다.

## 스케줄러

프로세스 스케줄러는 CPU 액세스를 통제한다. 실행 큐라는 큐를 이용한다.

스케줄러는 인터럽트에 응답하며 CPU 코어 액세스를 관리한다.

자바 명세서에는 이론적으로 자바 스레드가 굳이 OS스레드와 일치할 필요 없는 스레딩 모델을 허용한다고 하지만, 실제론 이런 방식이 유용하지 않다는 사실이 밝혀져 배제되었다.

## 시간문제

POSIX 같은 업계 표준이 있어도 OS는 다르게 동작한다.

호스트 OS가 제공하는 기능이라 네이티브 메소드로 구현된다.

## 컨텍스트 스위칭

OS 스케줄러가 현재 실행중인 스레드를 없애고 대기중인 다른 스레드로 대체하는 프로세스

유저 스레드 사이에서든, 유저 ↔ 커널에서든 컨텍스트 스위칭은 비ㅛㅇ이 비싸다.

유저 커널간 모드 변경이 더 비싸다.

커널모드로 컨텍스트가 변경되면 이전의 TLB 및 다른 캐시도 무효화된다.

# 기본 감지 전략

애플리케이션이 잘 작동하고 있다는 것은, CPU, 메모리, 네트워크, I/O 대역폭 등 시스템 리소스를 효율적으로 잘 이용하고 있다는 뜻이다.

## CPU 사용률

CPU 사용률은 애플리케이션 성능을 나타내는 핵심지표이다.

CPU 사이클은 애플리케이션이 가장 갈증을 잘 느끼는 리소스이기에 CPU의 효율적인 사용은 성능 향상의 지름길이다.

부하가 집중된다면 사용률이 100%에 가까워야 한다.

## 가비지 수집

어떤 JVM 프로세스가 유저 공간에서 CPU를 100%에 가깝게 사용중이라면 GC를 의심해야 한다.

JVM에서 GC 로깅은 공짜나 다름없고, 분석용 데이터로 가치가 높기에 운영환경에서는 꼭 GC로그를 남겨야한다.

## 입출력

자바 프로그램은 단순한 I/O만 처리하며 I/O 서브시스템을 심하게 가동하는 애플리케이션 클래스도 비교적 적은편이다.

그러면서 동시에 CPU, 메모리 어느 한쪽과 I/O를 동시에 고갈시키는 애플리케이션은 거의 없다.

### 커널 바이패스 I/O

커널을 이용해 데이터를 복사하여 유저 공간에 넣는 고성능 애플리케이션

커널 대신 네트워크 카드에서 유저가 접근가능한 영역으로 데이터를 매핑하는 전용 하드/소프트웨어를 사용함.

이는 자바가 구현한게 없어서 네이티브 라이브러리를 사용하여야 한다.

## 기계 공감

JVM이 하드웨어를 추상화했고 JVM이 무엇인지, 상호작용은 어떻게 하는지들을 이해해야 한다.

어느 것이 발생할 수 있는지를 염두에 둬야 해결 방법을 빠르게 찾아볼 수 있다.

# 가상화

가상화의 특징

- 가상화OS에서 실행하는 프로그램은 베어메탈에서 실행할 때와 동일하게 작동해야 한다.
- 하이퍼바이저는 모든 하드웨어 리소스 액세스를 조정해야 한다.
- 가상화 오버헤드는 가급적 작아야 하며 실행 시간의 상당 부분을 차지해선 안된다.

# JVM과 운영체제

JVM은 자바 코드에 공용 인터페이스를 제공하여 OS에 독립적인 실행환경을 제공한다.

스레드 스케줄링같은 기본적인 것도 OS에 반드시 액세스해야한다.

native 메소드는 C언어로 작성되지만, 자바 메소드처럼 액세스가 가능하다.

이러한 공통 인터페이스를 `자바 네이티브 인터페이스(JNI)` 라고 한다.
