# 3장 - 하드웨어와 운영체제

> 오랬동안 컴퓨터업계는 무어의 법칙대로 흘러갔다.
그 결과, 소프트웨어는 강력한 파워를 자유자재로 구사할 정도로 발전했음에도, 성능 향상을 꾀하려면 복잡한 기반 기술에 의지 할 수 밖에 없게 되었다.
이번 장에서 최신 하드웨어와 OS에 관해 빠르게 훑어보자.
> 

---

## 1. 최신 하드웨어 소개

아직도 많은 수업에서 CPU에 실제로 일어나는 일을 시키는 C프로그래밍이야 말로 진리의 원천인양 강조하는 편이지만 요즘은 이러한 생각은 맞지 않다.

1990년대 이후, 대부분 하드웨어는 인텔 x86/x64 아키텍처 위주로 돌아갔다. 

이제 프로세서 작동 원리를 단순화한 멘탈 모델(정신 모형)은 전혀 맞지 않고 그런 모델을 토대로 직관적인 추론을 하면 완전히 생뚱맞은 결론을 내리기 쉽습니다

---

## 2. 메모리

요즘 자바 개발자에게 가장 중요한 메모리를 살펴보자.

무어의 법칙에 따라 급증한 트랜지스터는 클록 속도를 높이는데 쓰였다. 클록 속도의 증가로 초당 더 많은 명령어를 처리할 수 있게 되었지만 시간이 갈수록 프로세서 코어의 데이터 수요를 메모리가 따라가 어려워 졌다. 

*4.77MHz(최초의 IBM PC칩) → 2GHz* 

클록 속도가 올라가도 데이터가 도착할 때까지 CPU는 놀면서 기다려야 하니 아무 소용 없게 됐다.

- 메모리  캐시
    
    CPU 캐시는 CPU에 있는 메모리 영역이다. 레지스터보다는 느리지만 메인 메모리 보다 훨씬 빠르다.
    
    액세스 빈도가  높은 캐시일수록 프로세서  코어와 더 가까이 위치하는 식으로 여러 캐시 계층이 있다. 
    
    클록 속도와 액세스 시간 차이를 줄이기 위해 최신 CPU는 캐시에많은 예산을 투자한다.
    
    메모리에 있는 데이터를 어떻게 처리하고 어떻게 메모리에 다시 써야할지 결정하기위해 **캐시 일관성 프로토콜**이라는 방법을 사용한다.
    

---

## 3. 최신 프로세서의 특성

메모리 캐시는 증가하는 트랜지스터를 확실하게 활용하는 주요 부분이지만, 수년간 여러 다른 기술도 등장했다.

- 변환 색인 버퍼 (TLB)
    
    가상 메모리 주소를 물리 메모리 주소로 매핑하는 페이지 테이블의 캐시 역할을 수행한다. 덕분에 가상 주소를 참조해 물리 주소에 액세스하는 빈번한 작업 속도가 매우 빨라진다.
    
    TLB가 없으면 캐시에 페이지 테이블이 있어도 가상 주소 룩업에 16사이클이나 걸리기 때문에 성능이 재대로 나오지 않는다.
    
- 분기 예측과 추측 실행
    
    분기 예측은 프로세서가 조건 분기하는 기준값을 평가하느라 대기하는 현상을 방지한다. 최신 프로세서는 다단계 명령  파이프 라인을 사용하는데, 이런 모델은 선행되는 조건문을 다 평가하기 전까지 다음 명령을 알 수 없다. 그 결과 분기 뒤에 나오는 다단계 파이프라인을 비우는 동안 프로세서는  여러 사이클 동안 멎게 된다.
    
    이런일이 없도록 프로세스는 트랜지스터를 다양하게 활용해 가장 발생 가능성이 큰 브랜치를 미리 결정하는 휴리스틱을 형성한다. 추측이 맞아 떨어지면 좋지만, 예측이 틀릴경우 부분적으로 실행한 명령을 모두 폐기한 후 파이프라인을 비우는 대가를 치룬다.
    
- 하드웨어 메모리 모델
    
    멀티코어 시스템에서 서로 다른 여러 CPU가 일관되게 동일한 메모리 주소를 액세스 할 수 있을까.
    
    JMM은 프로세서 타입별로 상이한 메모리 액세스 일관성을 고려하여 명시적으로 *약한 모델*로 설계되었다. 따라서 멀티스레드 코드가 제대로 작동하게 하려면 락과 volatile(휘발성)을 적확히 알고 사용해야한다.
    

---

## 4. 운영체제

OS의 주 임무는 여러 실행 프로세스가 공유하는 리소스 액세스를 관장한다. 한정된 리소스 가운데서도 메모리와 CPU 시간을 가장 중요한 리소스라고  할 수 있다. 

- 스케줄러
    
    프로세스 스케줄러는 CPU 엑세스를 통제한다. 이때 실행 큐를 이용하여 실행 대상을 관리하며 인터럽트에 응답하고 CPU 코어 엑세스를 관리한다.
    
    자바 명세서에 이론적으로 자바 스레드가 굳이 OS 스레드와 일치할 필요 없는 스레딩 모델(그린 스레드)을 허용하지만, 실제로 이런 방식은 유용하지 않아 주류에서 배재되었다.
    
    OS 특성상 CPU에 코드가 실행되지 않는 시간을 유발한다. 코드가 정작 실행되는 시간 보다 기다리는 시간이 더 많다는 뜻이다. 때문에 실제로 관측한 프로세스는 지터(불안전한 신호)와 스케줄링 오버헤드로 인해 노이즈가 발생한다.
    
    아래 코드로 스케줄링 오버헤드가 얼마나 될지 짐작할 수 있다.
    
    ```java
    long start = System.currentTimeMillis();
    for (int i = 0; i < 1_000; i++) { 
    		Thread.sleep(1);
    } 
    long end = System.currentTimeMillis();
    System.out.println("Millis elapsed: " + (end - start) / 4000.0);
    ```
    

- 컨텍스트 교환
    
    컨텍스트 교환은 OS 스케줄러가 현재 실행 중인 스레드/태스크를 없애고 대기 중인 다른 작업을 대체하는 프로세스이다. 
    
    유저 스레드 사이에 발생하든, 유저와 커널모드 사이에 발생하든 컨텍스트 교환은 비싼 작업이다. 특히 후자의 경우 유저의 공간과 커널 코드가 공유하는 부분이 거의 없기때문에 모드가 바뀌면 명령어와 TLB를 비롯한 다른 캐시를 모두 비워야한다.
    

---

## 5. 단순 시스템 모델

유닉스 계열 OS에서 작동하는 애플리케이션의 단순 개념 모델

- 애플리케이션이 실행되는 하드웨어와 OS
- 애플리케이션이 실행되는 JVM/컨테이너
- 애플리케이션 코드 자체
- 애플리케이션을 호출하는 외부  시스템
- 애플리케이션으로 유입되는 트래픽

이 중 누구라도 성능 문제를 일으킬 수 있다.

---

## 6. 기본 감지 전략

애플리케이션이 잘 돌아간다는 것은 CPU 사용량, 메모리, 네트워크, IO 대역폭 등 시스템 리소스를 효율적으로 잘 이용하고 있다는 뜻이다. 

성능 진단에 앞서 부족한 리소스가 뭔지 파악해악하고 튜닝 해야하지만 OS  자체가 시스템을 지치게 하는 원흉이 되어서도 안된다.

- CPU 사용률
    
    애플리케이션 성능을 나타내는 핵심 지표. 부하가 집중되는 도중에는 사용률이 가능한 100%에 가까워야한다.
    
    유닉스 계열 OS에 `vmstat`, `iostat`와 같은 기본 툴을 사용하면 현재 가상 메모리 및 IO 서브시스템  상태 관리 데이터를 제공한다. 
    
- 가비자 수집
    
    핫스팟 JVM은 시작 시 메모리를 유저 공간에 할당/관리한다. 그래서 운영 도중 메모리를 할당하는 시스템 콜을 할 필요가 없다. 즉, 가비지 수집을 위해 커널을 교환하는 일은 거의 없다.
    
    때문에 어떤 JVM 프로세스가 유저  공간에서 CPU를 100% 가까이 사용하고있다면 GC를 의심해봐야한다.
    
- 입출력
    
    파일 IO는 예로부터 전체 시스템 성능에 암적인 존재이다. 물리적 하드웨어와 밀접한 연관이 있기도 하지만 다른 OS 파트처럼 분명하게 추상화되어 있지 않다.
    
    - 커널 바이패스 I/O
        
        커널을 이용해 데이터를 복사해 유저 공간에 넣는 작업으로 상당히 비싼 고성능 애플리케이션이 있다. 그래서 커널 대신 직접 네트워크 카드에서 유저가 접근 가능한 영역으로 데이터를 매핑하는 전용 하드웨어/소프트웨어를 쓴다.
        

---

## 7. 가상화

이미 실행 중인 다른 OS 위에 OS 사본을 하나의 프로세스로 실행시키는 모양새.

가상화 시스템에서는 게스트 OS가 하드웨어를 직접 액세스할수  없어 대게 명령어를 언프리빌리지드(비특권) 명령어로 고쳐쓴다. 커널의 자료구조를 섀도하여 컨텍스트 교환이 발생할때 지나친 캐시 플러시가 일어나지 않지만, 가상 환경 내에서 프로그램을 실행한다는 것 자체가  성능 분석 및 튜닝을 한층 복잡하게 만든다.
