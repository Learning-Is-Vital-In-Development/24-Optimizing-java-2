# 6. 가비지 수집 기초
- 시스템에 있는 모든 객체의 수명을 몰라도 런타임이 객체를 추적해서 쓸모없는 객체를 제거한다.
- GC 구현 원칙
  - 모든 가비지 수집
  - 살아있는 객체 제거 X (SEG FAULT)
## 6.1 마크 앤 스윕
- 마크 앤 스윕
  - 할당 리스트를 순회 하면서 마크 비트 지운다. 
    - GC 루트부터 살아 있는 객체 식별
    - 객체마다 마크 비트 셋업
  - 마크 비트 없는 객체는
    - 힙에서 메모리 회수
    - 할당 리스트에서 객체 삭제
  - 라이브 객체 그래프 (dfs 로 객체들 식별)
  - `jmap -histo` 하면 객체별 heap 상태를 볼 수 있습니다.
### 6.1.1 가비지 수집 용어
- STW (STOP THE WORLD)
- 동시
- 병렬
- 정확
- 보수
- 이동
- 압착(COMPACT)
- 방출

## 6.2 핫스팟 런타임 개요
- JAVA는 기본형, 레퍼런스로 CALL BY VALUE 한다.(힙에 있는 객체의 주소)

### 6.2.1 객체를 런타임에 표현하는 방법
- OOP라는 구조체를 사용해서 객체를 표현합니다.
  - Mark 워드
  - Klass 워드
  - LENGTH
  - 32비트 여백
- OOP 상속 구조
  - instanceOop
  - methodOop
  - arrayOop
  - symbolOop
  - klassOop
  - markOop
### 6.2.2 GC 루트 및 아레나
- GC 루트는 메모리의 고정점으로 메모리 풀 외부에서 내부를 가리키는 포인터입니다.
- 내부 포인터와 외부 포인터가 있습니다.
  - GC 루트의 종류
    - 스택 프래임
    - JNI
    - 레지스터
    - 전역 객체
    - 클래스의 메타데이터
- 핫스팟 GC는 아레나라는 메모리 영역에서 일어납니다.
- 핫스팟은 자바 힙을 관리할 떄 시스템 콜을 하지 않습니다.
- 핫스팟은 유저공간 코드에서 힙크기를 관리해서 측정값을 확인해서 성능 문제를 확인 할 수 있습니다.
## 6.3 할당과 수명
- 할당률
  - 일정 기간 새로 생성된 객체가 사용한 메모리 량입니다. (JVM이 기록X 쉽게 측정가능)
- 객체 수명
  - 제대로 측정하기 어렵다.
### 6.3.1 약한 세대별 가설
- 객체 수명은 BINOMIAL DIST 를 따릅니다.
- 대부분의 객체는 짧은 시간을 살아 있고 다른 객체들은 수명이 훨씬길다.
- 핫스팟은 지표를 모읍니다.
  - GENERATION COUNT(GC 통과 횟수)
  - EDEN (YOUNG)
  - OLD, TENURED(OLD)
- 늙은 객체가 젊은 객체를 참조하는일은 거의 없다.
- 카드 테이블이라는 구조에 늙은 객체가 젊은 객체를 참조하는 정보를 기록합니다.
  - 늙은 객체의 o 에 있는 참조 형 필드값이 바뀌면 해당 엔트리를 더티 마킹합니다.
  
## 6.4 핫스팟 JVM 의 가비지 수집 
- 자바는 OS를 이용해 동적으로 메모리를 관리하지 않습니다.
- 프로세스 시작 -> JVM 메모리 할당 -> 단일 메모리풀 관리
- 방출 -> 수집기가 객체들을 에덴 -> 에덴 -> 테뉴어로 이동시킴
- 
### 6.4.1 스레드 로컬 할당
- JVM은 성능을 강화하여 에덴을 관리
- 여러 버퍼로 나눠서 각 애플리케이션 스레드가 새객체를 할당하는 구역으로 배포
- 각 스레드가 스레드 로컬 할당 버퍼(TLAB)을 받게됨 (동적 할당)
- 스레드가 버퍼를 다 채우면 JVM은 새 에덴 영역을 가르키는 포인터를 내줍니다.

### 6.4.2 방출형 수집
- 장수하지 못한 객체를 임시 수용소에 담자
- 테뉴어드 세대를 어지립히지 않고 풀 GC 발생 빈도 줄이기
  - 수집기가 라이브 반구를 수집할 때, 객체들은 다른 반구로 압착시켜 옮기고 수집된 반구는 비워서 재사용
  - 절반의 공간은 항상 완전히 비운다.
- 핫스팟에서 영 힙의 반구부를 서바이버 공간이라고 합니다.
- VISUAL gc 플러긴을 사용하면 gc 로그를 확인할 수 있습니다.

## 6.5 병렬 수집기
- JVM 디폴트 가비지 수집기는 병렬 수집기입니다.
- 처리율에 최적화 되어 있습니다.
- 영 GC, 풀 GC 모두 풀 STW를 일으팁니다.

- 병렬 수집기 종류
  - Parallel GC
  - ParallelOld GC
- 영세대 수집은 가장 흔한 가비지 수집 형태입니다.
- 스레드가 에덴에 객체를 할당하려는데 자신이 할당받은 TLAB 공간이 부족하면 영세대 수집을 발생시킵니다.
- JVM은 그떄 할수없이 STW 합니다.
- 스레드가 중단되면 핫스팟은 영세대를 뒤져서 가비지 아닌 개게를 골라냅니다.
- Parallel GC는 살아남은 객체를 현재 비어있는 서바이버 공간으로 모두 방출한후, 세대 카운트를 늘려 한차례 이동했음을 기록합니다.
  - 에덴과 객체를 방출 시킨 서바이버 공간을 재사용가능한 빈 공간으로 표시하고 TLAB을 스레드에 배포합니다.
  - 살아있는 객체만 건드려서 약한 세대별 가설을 활용
  - STW 중단시간을 조금이라도 단축해서 효율적으로 수집하겠다는 의도
### 6.5.2 올드 세대 병렬 수집
- 하나의 연속된 메모리 공간에서 압착하는 수집기
- 아주 효율적이고 메모리 단편화가 일어날 일도 없다.
- 올드 공간은 크게 눈에 띄는 변화가 없습니다.
- ParallelOld GC는 하나의 연속된 메모리 공간에서 압착하는 수집기이비다.
- 메모리 단편화 안일어난다. 효율적이다.

### 6.5.3 병렬 수집기의 한계
- 풀 STW 유발한다.
- 영 수집은 살아있는 객체에 STW 시간이 비례한다 10ms
- 올드 수집은 stw 시간이 힙크기에 비례 
- 손쉬운 스레드 생성이 자바의 강력한 장점 하지만 새로운 실행 스택들이 gc 루트의 원천이라서 gc가 복잡해진다.

## 6.6 할당의 역할
- 유입된 메모리 할당 요청을 수용하기에 메모리가 부족할 때 작동해서 필요한 만큼 메모리 공급
- 힙 메모리 공간이 꽉채워져 더이상 객체를 생성할 공간이 없을 대 일어난다. (불규칙함)
- gc 가 발생하면 모든 애플리케이션 멈춤
- visual vm으로 메모리 사용패턴을 잘 보면 힙사용률이 톱니바퀴로 나타나게 된다.
- 할당률이 너무 높음 -> 조기승격하게됨
- 튜닝 포인트가 된다.


