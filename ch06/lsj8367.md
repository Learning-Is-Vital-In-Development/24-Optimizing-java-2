# 6장. 가비지 수집 기초

GC(Garbage Collector)는 자바 환경을 상징하는 여러 특성 가운데 돋보이지만, 자바 플랫폼이 처음 출시됐을 때 상당한 반감을 샀다.

모든 가바지 컬렉터는 기본원칙을 준수해야 한다.

- 알고리즘은 반드시 모든 가비지를 수집해야 한다.
- 살아있는 객체는 절대로 수집해선 안된다. (해당 내용이 더 중요)

## 마크 앤 스위프

1. 할당 리스트를 순회하며 마크 비트를 지운다.
2. GC 루트부터 살아있는 객체를 찾는다.
3. 이렇게 찾은 객체마다 마크 비트를 세팅한다.
4. 할당 리스트를 순회하며 마크 비트가 세팅되지 않은 객체를 찾는다
    1. 힙에서 메모리를 회수해 프리 리스트에 되돌린다.
    2. 할당 리스트에서 객체를 삭제한다.

살아있는 객체는 dfs 방식으로 찾아낸다.

이 객체 그래프를 라이브 객체 그래프 or 접근 가능한 객체의 전이 폐쇄라고 한다.

## 가비지 수집 용어

### STW (Stop The World)

gc 사이클이 발생하여 가비지 수집하는 동안 모든 애플리케이션의 스레드가 중단된다.

애플리케이션 코드는 gc 스레드가 바라보는 힙 상태를 무효화 할 수 없다.

### 동시

gc 스레드는 애플리케이션 스레드와 동시 실행될 수 있다.

### 병렬

여러 스레드를 동원해서 가비지 수집

### 정확

정확한 gc 스킴은 가비지를 한방에 수집할 수 있게 힙 상태에 관한 충분한 타입 정보를 지니고 있다.

int와 포인터의 차이점을 언제나 분간할 수 있는 속성을 지닌 스킴이 정확한 것.

### 보수

보수적인 스킴은 정확한 스킴의 정보가 없다.

리소스 낭비하는 일이 잦고 근본적으로 타입 체계를 무시하기에 비효율적이다.

### 이동

이동 수집기에서 객체는 메모리를 여기저기 오갈 수 있다.

객체 주소가 고정된 것이 아니다

### 압착

할당된 메모리는 gc 사이클 마지막에 연속된 단일 영역으로 배열된다.

객체 쓰기가 가능한 여백의 시작점을 가리키는 포인터가 있다.’

압착 수집기는 메모리 단편화를 방지한다.

### 방출

수집 사이클 마지막에 할당된 영역을 완전히 비우고 살아남은 객체는 모두 다른 메모리 영역으로 이동한다.

# 핫스팟 런타임 개요

자바언어에서는 다음 두가지 값만 사용한다.

- 기본형
- 객체 레퍼런스

## 객체를 런타임에 표현하는 방법

핫스팟은 런타임에 oop라는 구조체로 자바 객체를 나타낸다.

oop는 평펌한 객체 포인터의 줄임말

oop는 참조형 지역변수 안에 위치하고, 여기서 자바 메소드의 스택 프레임으로부터 자바 힙을 구성하는 메모리 영역 내부를 가리킴

oop를 구성하는 자료구조 중 instanceoops는 자바 클래스의 인스턴스를 나타낸다

instanceoops의 메모리 레이아웃은 모든 객체에 대해 기계어 워드 2개로 구성된 헤더로 시작한다

인스턴스 관련 메타데이터를 가리키는 Mark 워드와 클래스 메타데이터를 가리키는 Klass 워드가 나온다.

자바 7까지는 Klass 워드가 힙의 일부인 PermGen영역을 가리켰다.

자바 8부터는 Klass가 자바 힙의 주 영역 밖으로 빠지게 됐고, Klass 워드가 힙밖을 가리키므로 객체 헤더가 필요없다.

oop는 대부분 기계어라서 비트 구조로는 메모리가 크게 낭비될 우려가 있기 때문에 메모리를 절약할 수 있게 압축 oop라는 기법을 제공한다.

`-XX:UserCompressedOops` 라는 옵션을 주면 힙에있는 oop가 압축된다.

- 힙에 있는 모든 객체의 Klass 워드
- 참조형 인스턴스 필드
- 객체 배열의 각 원소

> 핫스팟 객체 헤더
> 
- Mark 워드 (32비트 환경은 4바이트, 64비트 환경은 8바이트)
- Klass 워드 (압축됐을 수도 있음)
- 객체가 배열이면 length 워드 (항상 32비트임)
- 32비트 여백(정렬 규칙 때문에 필요할 경우)

자바에서 배열은 객체다. 그래서 JVM 배열도 oop로 표시되고, 배열은 Mark워드, Klass 워드 다음에 배열 길이를 나타내는 length 워드가 붙는다.

자바 배열 인덱스가 32비트 값으로 제한되는건 이 때문이다.

JVM 환경에서 자바 레퍼런스는 instanceOop 또는 null 을 제외한 어떤 것도 가리킬 수 없다.

- 자바 값은 기본형 또는 instanceOop 주소에 대응되는 비트 패턴이다
- 모든 자바 레퍼런스는 자바 힙의 주 영역에 있는 주소를 가리키는 포인터라고 볼 수 있다
- 자바 레퍼런스가 가리키는 주소에는 Mark 워드 + Klass 워드가 들어있다
- klassOop와 Class<?> 인스턴스는 다르며, klassOop를 자바 변수 안에 넣을 수 없다

> oop의 전체 상속 구조
> 

```jsx
oop(추상베이스)
  instanceOop(인스턴스 객체)
  methodOop(메소드 표현형)
  arrayOop(배열 추상 베이스)
  symbolOop(내부 심볼 / 스트링 클래스)
  klassOop(Klass 헤더) 자바 7이전만 해당
  markOop
```

## GC 루트 및 아레나

GC루트는 핫스팟에 관한 블로그 글이나 기사에서 자주 나오는 말

GC루트는 메모리의 고정점으로 메모리 풀 외부에서 내부를 가리키는 포인터이다.

내부 포인터 - 메모리 풀 내부에서 메모리풀 내부 다른 메모리 위치를 가리키는 포인터

외부 포인터 - 메모리 풀 외부에서 메모리풀 외부 다른 메모리 위치를 가리키는 포인터

### GC 루트

- 스택프레임
- JNI (Java Native Interface)
- 레지스터
- 코드 루트
- 전역 객체
- 로드된 클래스의 메타데이터

핫스팟 GC는 아레나 라는 메모리 영역에서 작동함.

**핫스팟은 힙 관리 시 시스템 콜을 하지 않는다.**

## 할당과 수명

가비지 수집이 일어나는 주된 원인

- 할당률
    - 일정 기간 새로 생성된 객체가 사용한 메모리량
- 객체 수명

객체 수명은 대부분 측정하기 어려움.

## 약한 세대별 가설

소프트웨어 시스템의 런타임 작용을 관찰한 결과 알게된 경험지식으로 JVM 메모리 관리의 이론적 근간을 형성한다

## 핫스팟의 가비지 수집

자바는 C언어의 환경과 달리 OS를 이용하여 동적으로 메모리 관리를 하지 않는다.

프로세스 시작 시 JVM 메모리를 할당하고 유저 공간에서 연속된 단일 메모리 풀을 관리한다

## 스레드 로컬 할당

JVM은 성능을 강화하여 에덴 영역을 관리한다.

에덴은 대부분의 객체가 탄생하는 장소이고 단명 객체는 다른 곳에 위치할 수 없기에 관리를 잘 해주어야 하는 영역이다

JVM은 에덴을 여러 버퍼로 나누어 각 애플리케이션 스레드가 새 객체를 할당하는 구역으로 활용하도록 배포한다.

이렇게 구성하면 다른 스레드가 자신의 버퍼에 객체를 할당하는 경우를 고려할 필요가 없어진다.

이를 스레드 로컬 할당 버퍼라고 칭한다