# 10. JIT 컴파일
- JITWatch를 이용해서 핫스팟이 실제로 바이트코드에 무엇을 했는지 이해하는데 도움이 되고 측정할 수 있습니다.
- 핫스팟 컴파일 상세로그를 분석하여 자바 FX GUI 형태로 보여줍니다.
- `-XX:+UnlockDiagnosticVMOptions -XX:+TraceClassLoading -XX:+LogCompilation` 으로 스위치를 켜야한다.
### 10.1.1 기본적인 JITWatch 뷰
- 샌드박스에서 간단한 애플리케이션에 대한 최적화를 실험해 볼 수 있습니다.
- 3단 뷰에서
  - 소스콛, 바이트코드 어셈블리로 어떻게 컴파일도니ㅡㄴ지 보여줍니다.
  - java 8이전에는 컴파일드 메서드, 논프로파일드 메서드, vm 자체 네이티브 코드를 하나의 코드 캐시영역에 담았습니다.
  - java 9 부터는 분할 코드 캐시가 새로 생겨서 네이티브 코드 유형마다 별도의 영역에 저장할 수 있습니다.
### 10.1.2 디버그 JVM과 hsdis
- JIT 서브시스템의 통계치를 얻으려면 디버그 JVM을 이용하면 됩니다.
- 디버그 JVM은 운영 JVM보다 더 상세한 디버깅 정보를 추출하려고 제작한 가상 머신입니다.

## 10.2 JIT 컴파일 개요
- 핫스팟은 프로파일 기반 최적화(PGO)를 통해 JIT 컴파일 여부를 판단
- 핫스팟이 실행 프로그램 정보를 메서드 데이터 객체라는 구조체에 저장
- MDO는 바이트 코드 인터프리터와 C1 컴파일러에서 JIT 컴파일러가 언제 무슨 최적화를 할지 결정하는데 필요한 정보를 기록
  - 어떤 메서드가 호출됐고, 어느 분기문으로 갈라졌고, 호출부에서는 무슨 타입이었는지 담겨져있습니다.
- 사용빈도를 카운터에 계속 기록하고 그렇게 기록한 값들은 프로파일링을 거치면서 차츰 사라집니다.
- 컴파일러는 컴파일할 코드의 내부 표현형을 빌드합니다.
  - 인라이닝
  - 루프 펼치기
  - 탈출 분석
  - 락 생략/확장
  - 단일형 디스패치
  - 인트린직
  - 온-스택 치환
- c1은 추측성 최적화하지않고
- c2는 공격적인 최적화기로 런타임 실행을 주시한 결과를 토대로 추정하고 최적화를 수행합니다.
- 큰 성능 향상효과를 볼 수 있습니다.
- `가드`라는 타당성 검사를 합니다.
- 가드마저 실패하면 컴파일드 코드는 안전하지 않아서 제거하게 됩니다.

## 10.3 인라이닝
- 인라이닝은 호출된 메서드의 콘텐츠를 호출한 지점에 복사하는 것입니다.
- 호출시의 오버헤드를 제거할 수 있습니다.
  - 전달할 매개변수 세팅
  - 호출할 메서드를 룩업
  - 런타임 자료구조(지역 변수, 평가스택) 생성
  - 새 메서드로 제어권 이송
  - 호출부에 결과 반환
- 제일 먼저 적용하는 최적화로 `관문 최적화`라고 불립니다.
- 해당 전략들의 근간이 됩니다.
  - 탈출분석
  - DCE(죽은 코드 제거)
  - 루프 펼치기
  - 락 생략
### 10.3.1 인라이닝 제한
- JIT 컴파일러가 메서드를 최적화하는데 소비하는 시간
- 생성된 네이티브 코드 크기(코드 캐시 메모리 사용량)
- 핫스팟의 인라이닝 조건
  - 인라이닝할 메서드의 바이트코드 크기
  - 현재 호출 체인에서 인라이닝할 메서드의 깊이
  - 메서드를 컴파일한 버전이 코드 캐시에서 차지하는 공간

### 10.4 루프 펼치기
- 순회할 때 마다 루프 처음으로 되돌아가는 횟수를 줄이기 위해 루프를 펼칠 수 있습니다.
- 백 브랜치가 일어나면 그때마다 CPU는 유입된 명령어 파이프라인을 덤프하기 때문에 성능상 바람직 하지 않습니다.
  - 백 브랜치란 배열 인덱스 변수가 배열 경계내에 있는지 확인하는 작업
  - 루프 바디가 짧을수록 백브랜치 비용은 상대적으로 높습니다. 핫스팟은 다음 기준을 가지게 됩니다
    - 루프 카운터 변수 유형(대부분 INT 사용)
    - 루프 보폭(한번 순회할 때, 루프 카운터 값이 얼마나 바뀌는가?)
    - 루프 내부의 탈출 지점 개수(RETURN 또는 BREAK)
    - BASE 레지스터
    - INDEX 레지스터
    - OFFSET
  - 루프 펼치기는 핫스팟 버전별로 로직이 상이하고 아키텍쳐마다 많이 다릅니다.
  - 사전 루프
    - 경계 검사
  - 메인 루프
    - 경계 검사 x 순회 가능한 최대 횟수를 센다.
  - 사후 루프
    - 경계 검사 
  - long으로 순회하기 vs int로 순회하기
    - int 형 카운터 루프의 처리량이 64퍼센트 높다.
    - long형 카운터를 쓰면 루프바디가 펼쳐지지 않고 루프안에 세이프 포인트 폴이 박힙니다.
      - 오랜기간 걸리는 컴파일 코드는 세이프 포인트 폴이 삽입됩니다.
- 루프 펼치기 정리
  - 카운터가 int, short, char 형일때 루프를 최적화합니다.
  - 루프 바디를 펼치고 세이프포인트폴을 제거합니다.
  - 루프를 펼치면 백 브랜치 횟수가 줄고 분기 예측 비용도 줄어듭니다.
### 10.5 탈출 분석
- 메서드 내부 수행 작업이 메서드 경계밖에서 볼수 있는지 side effect가 있는지 범위기반분석으로 판별합니다.
- 인라이닝해서 피호출부 메서드 바디를 호출부에 복사하면 호출부에 메서드 인수로 전달된 객체는 더이상 탈출 객체로 표시되지 않기 때문입니다.
  - NOESCAPE -> 스칼라로 대체가능
  - ArgsEscape -> 호출 인수로 전달되거나 레퍼런스로 참조됨 호출 도중에는 탈출 하지 않는다.
  - GlobalEscape -> 객체가 메서드를 탈출한다.
### 10.5.1 힙 할당 제거
- 빡빡한 루프 안에서 객체를 새로 만들면 그만큼 메모리 할당 서브시스템을 압박하게 되고 마이너 gc 이벤트가 많이 발생해서
  - 영세대가 꽉차고 단명개체가 올드세대로 조기 승격할 수 있습니다.
  - 이지경에 이르면 풀 gc이벤트를 발생시키겠죠
- VM은 스칼라 치환이라는 최적화를 적용해 객체 필드를 지역변수였던것처럼 스칼라 값을 바꿈 (NOESCAPE 경우)
- 레지스터 할당기라는 컴포넌트에 의해 CPU 레지스터로 할당.
- 탈출 분석의 목표는 힙 할당을 막을 수 있는지 추론. 스택에 할당되고 GC압박을 던다.
  - 예시
    - foo가 인수로 전달되면 argEscape (값이 다른 메서드의 인수로)
      - 하지만 inlining이 되면 NoEscape로 변신이 가능함
    - foo가 메서드만 부르면 noEscape
### 10.5.2 락과 탈출 분석
- 핫스팟은 탈출 분석 및 관련 기법을 통해 락 성능도 최적화 합니다.
  - 비탈출객체에 있는 락은 제거한다.
  - 같은 락을 공유한 영역은 병합한다.
    - 핫스팟은 같은 객체에 걸린 중첩락을 감지해서 이미 락획득 상태면 내부락을 제거
  - 해제하지 않고 같은 락을 반복획득한 블록을 찾아낸다.
- 두 락 영역을 더 큰 단일 영역으로 합할 수 있는지 살핍니다.
### 10.5.3 탈출 분석의 한계
- 탈출 분석 역시 트레드 오프가 있습니다.
  - register는 희소한 리소스인데 기본적으로 원소가 64개 이상인 배열은 탈출 분석으 ㅣ혜택을 볼 수 없습니다.
  - 배열 길이가 64를 초과하면 무조건 힙에 저장되고 코드의 할당률은 빠르게 상승합니다.
  - jmh 벤치시에 성능이 떨어집니다.
  - 분기 조건안에 객체 할당을 묶어버리면 탈출 분석의 혜택을 볼 수 있습니다. 그렇지 않으면 -> 객체 할당률 + GC 압 가중
## 10.6 단형성 디스패치
- C2 컴파일러가 수행하는 추측성 최적화는 대부분 경험적 연구 결과를 토대로 합니다.
- 단형성 디스패치는 한가지 런타임 타입이 수신자 객체 타입이 된다라는 팩트를 관찰한 것입니다.
- 어떤 객체에 있는 메서드를 호출 할때, 그 메서드를 최초로 호출한 객체의 런타임 타입을 알아내면 그 이후의 모든 호출도
  - 동일한 타입일 가능성이 크다.
- 해당 추측성 가설이 옳다면
  - 해당 호출부의 메서드 호출을 최적화 할수 있습니다.
  - 특히, VTABLE에서 에둘러 메서드를 찾을 필요가 없습니다.
  - invokevirtual로 가드후에 메서드 바디로 분기하는 코드로 치환하면 됩니다.
  - klass 포인터 및 vtable을 통해 룩업하는것을 딱 한번만 하면 됩니다.
- `java.util.Date date = getDate();` 
  - -> getDate().toInstant() 가 java.util.Date만 반환하면 단형적이고
  - getDate().toInstant() 가 java.sql.Date를 반환하면 다른 구현체를 호출해야하니 추정이 안맞습니다.
  - 서로 다른 두 타입을 호출부에서 상이한 klass 워드를 캐시해서 처리합니다.
  - 이 호출부를 다형성이라고 합니다.
  - 이 다형성도 instanceof 같이 벗겨내어 최적화도 가능합니다.
## 10.7 인트린직
- 인트린직은 jit 서브시스템이 동적 생성하기 이전에 jvm이 알고있는 네이티브 메서드 구현체를 가리키는 용어입니다.
- 하드웨어 최적화 되어있다.
- Math.min()
- currentTimeMillis()
- JVM의 복잡성 가중시키기는 한다.
## 10.8 온-스택 치환
- 호출 빈도가 높지는 않지만 메서드 내부에 핫 루프가 포함된 경우가 있습니다.
- 핫스팟은 이런 코드를 온스택 치환을 이용해 최적화 합니다.
- 루프백 브랜치 횟수르 세어보고 한계치를 초과하면 컴파일한 후 치환해서 실행합니다.

## 10.9 세이프 포인트 복습
- 세이프 포인트 조건들
  - 메서드 역최적화
  - 힙 덤프 생성
  - 바이어스 락 취소
  - 클래스 재정의
  - 루프 백 브랜치 지점
  - 메서드 반환지점
- 오래걸리는 룹안에서 세이프 폴링을 할지도 성능 최적화의 관심사이다.

## 10.10 코어 라이브러리 메서드
- jarScan으로 바이트코드 한계치 이상 메서드 모두 찾아냅니다
- 인라이닝 하기 최적화 사이즈로 줄여 낼 수 있습니다.
- 메서드 작게하면 좋은점
  - 인라이닝 가짓수를 늘릴수있습니다.
  - 런타임 데이터가 다양해질수록 코드가 핫하게 될 가능성이 있습니다.
  - 다양한 인라이닝 트리는 핫 경로를 최적화할 여지가 생깁니다.
  - 메서드가 커지면 인라이닝 한계치를 초과해서 최적화 경로 포함 되지 않습니다.

## 10.11
- 먼저 좋은 코드를 작성하고 필요한 경우만 최적화하라
  - 인라이닝 한계치 확인
  - 단형성 디스패치 확인
    - 구현체가 하나라도 인터페이스에 맞게 설계
