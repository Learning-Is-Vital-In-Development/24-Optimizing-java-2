# 4장. 성능 테스트 패턴 및 안티패턴

# 4.1 성능 테스트 유형

테스트를 할 때에는 해당 도메인을 생각해야한다.

## 4.1.1 지연테스트

가장 일반적인 성능 테스트

고객이 트랜잭션 처리를 얼마나 기다려야 하는지를 테스트하는 기법.

## 4.1.2 처리율 테스트

지연테스트 다음으로 일반적인 테스트

상황에 따라 처리율은 지연과 동등한 개념을 가질 수 있다.

지연 분포가 갑자기 변하는 시점(한계점 or 변곡점)이 `최대 처리율` 이다.

## 4.1.3 부하 테스트

처리율 테스트와는 조금 다르고

이정도의 부하를 견딜 수 있을까? 를 테스트하는 기법이다.

서비스로 생각하면 어떤 선착순 이벤트 같은 것들을 처리할 때 테스트해볼 수 있을 것 같다.

## 4.1.4 스트레스 테스트

시스템 여력이 어느정도인지 알기위한 테스트

어떤 고정된양의 트래픽을 정해두고 지속적으로 요청을 했을 때 동시 트랜잭션이 증가하고, 시스템 성능이 저하되는 시점을 추적한다.

→ 이 부분이 최대처리율

## 4.1.5 내구 테스트

메모리 누수, 캐시 오염, 메모리 단편화(CMF Concurrent Mode Failure) 등

시간이 한참 지나고 나서 드러나는 문제점들을 이 테스트로 감지한다.

평균적으로 사용하는 부하를 계속해서 주고, 리소스가 고갈되거나 깨지는 지점을 찾는다.

빠른 응답을 요구하는 시스템에서 많이 사용하는 기법이다.

## 4.1.6 용량 계획 테스트

스트레스 테스트와 여러모로 비슷하지만, 차이점이 있다.

> 차이점
>
- 스트레스테스트
    - 현재 시스템이 어느정도 부하를 버틸 수 있는지 테스트
- 용량 계획 테스트
    - 업그레이드한 시스템이 어느정도 부하를 감당할 수 있을까? 를 측정하는 테스트

이벤트처럼 단발성 기능에 대한 테스트가 아니다.

## 4.1.7 저하 테스트

부분 실패 테스트라고도 한다.

failover 대책이 잘 잡혀있는 환경에서 수행해볼 수 있는 테스트이다.

책에서는 복원테스트를 생각하면 된다.

→ 시스템이 기능을 잘 수행하다가, 갑자기 능력치가 떨어지는 시점에 생기는 일들을 확인한다.

### 눈여겨 봐야할 점

- 트랜잭션 지연 분포
- 처리율

> 카오스 멍키
>

부분 실패 테스트 중 하위 유형

복원성이 강한 아키텍처에서는 한 컴포넌트가 잘못되어도 다른 컴포넌트까지 장애전파를 하는일이 없어야하는 것을 말한다. → MSA 장애전파

카오스 멍키는 실제 운영환경에 있는 라이브 프로세스를 하나씩 죽이면서 검증한다.

# 4.2 기본 베스트 프랙티스

성능 튜닝시 3가지 기본 원칙에 따라 결정한다.

1. 나의 관심사 식별 및 측정 방법을 고민
2. 최적화하기 용이한 부분이 아니라, 중요한 부분을 최적화한다.
3. 중요한 관심사를 먼저 다룬다.

## 4.2.1 하향식 성능

자바 애플리케이션을 대규모 벤치마킹하는 일이 코드 섹션별로 정확하게 수칠르 얻는것보다 쉽다.

하향식 성능 접근 방식으로 성과를 극대화하기 위해서는 테스트팀이 테스트 환경을 구축

성능 활동을 전체 소프트웨어 개발 주기에서 어떻게 병행해야 하는지

전체 팀원이 명확하게 이해

## 4.2.2 테스트 환경 구축

성능 테스트팀이 가장 먼저 할 일

가급적 모든 면에서 운영환경과 똑같이 복제해야 한다.

(서버, DB,  로드밸런서, 방화벽 등)

→ 운영환경에 존재하는 개인정보나 옮길 수 없는 공인인증서 같은 데이터는 어떻게 처리해야할까?

클라우드 환경으로 변화했어도 테스트 환경을 구축하는 프로세스는 무조건적으로 수립해야 할 것이다.

## 4.2.3 성능 요건 식별

전체 시스템 성능은 OS, 하드웨어까지 고려가 되어야 한다.

코드 관점에서만 성능을 평가해서도 안되고, 전체적으로 바라보면서 측정값을 고려해주어야 한다.

이렇게 최적화하는 지표를 성능 비기능 요건이라고 한다.

## 4.2.4 자바의 특정이슈

JIT 컴파일은 중요한 부분.

최신의 JVM은  어떤 메소드를 JIT 컴파일해서 최적화한 기계어로 변환할지 분석한다.

JIT 컴파일을 안하기로 결정된 메소드종류

- JIT 컴파일 할정도로 자주 실행되는 메소드가 아니다.
- 메소드가 너무 크고 복잡해서 컴파일 분석을 할 수 없다.

## 4.2.5 SDLC 일부로 성능 테스트 수행하기

SDLC(Software Development LifeCycle)의 일부로 성능테스트를 수행

특히 성능 회귀 테스트를 상시 수행하는 편이다.

어느 시점에 어떤 버전코드로 성능 테스트 환경에 배포할지를 개발팀과 인프라팀이 협의해서 결정한다.

→ 이는 너무 최상의 프랙티스이다.

# 4.3 성능 안티패턴 개요

성능 튜닝은 초기 기획단계부터 구체적으로 목표를 정해놓고 시작하는 목표지향 프로세스로 접근해야 한다.

그리고 팀이 심한 일정 압박을 받고있거나 상식적으로 일 처리가 되지 않는 환경이라면 중도 실패할 가능성이 크다.

새로운 기능을 오픈할 때 예측하지 못한 사고가 있을 수 있는데, 이를 인수테스트 도중 발견했다면 다행이지만, 배포 이후에 사고가 터지는 경우를 많이 경험했다.

→ 이렇게 되는 것은 성능 테스트를 1회도 수행하지 않았거나 팀 일원중 하나가 온갖 추측만하고 도망간 경우들이 이 케이스에 해당할 수 있다.

팀원간에 활발한 의사소통이 일어나지 않는다면 해당 케이스에 말려들 가능성이 높다.

아래부터는 개발자가 잘못된 기술 선택을 하는 경우에 대한 케이스들이다.

## 4.3.1 지루함

개발자 대부분이 자기 역할에 지루함을 느끼고 새롭게 도전적인 일들을 찾아 같은 회사 또는 다른 곳으로 떠나려고 하는 사람들이 있다.

개발자의 지루함이 단순한 유틸 메소드 한줄이면 될 것을 요상한 알고리즘을 통해 구현하여 필요 이상으로 코딩하는 개발자가 있다. 뿐만 아니라 알려지지 않은 기술로 컴포넌트 제작 및 맞지도 않는 유즈케이스를 도입하여 기술을 욱여넣는 것들도 포함된다.

## 4.3.2 이력서 부풀리기

이력서를 과대 포장할 구실을 찾는 개발자

내 연봉과 몸값을 어떻게 높일 수 있을까? 를 시작으로 불필요한 기술을 붙인경우는 이 사람이 이직한 이후 오랫동안 시스템에 녹아들게 될 것이다.

## 4.3.3 또래 압박

기술을 결정할 때 관심사 밝히기와 논의가 충분하지 않은경우 결과가 좋지 못할 수 있다.

실수를 안하려는 주니어가 잘 모른다는 사실을 두려워하는 것도 있다.

이 때 경쟁심 때문에 분위기 속에서 개발 진행만 엄청나게 되어야 하는 경우에 섣부른 판단으로 중요한 결정을 막 내린경우 문제가 된다.

## 4.3.4 이해 부족

지금 사용하는 기술이나 툴도 어리숙하게 사용하는데, 추가적으로 어떤 툴로 문제 해결을 하려는 경우가 문제될 수 있다.

가장 들기 쉬운예가 JPA일 수 있다.

개인적인 의견으로 객체지향에 대한 공부가 빈약할 때 JPA를 쓰면 Mybatis를 쓰는것만 못한정도로 JPA를 쓰면서 항상 Lock이 잡히거나 하는 문제들을 많이 봤다.

## 4.3.5 오해와 있지도 않은 문제

문제가 뭔지 모르는채로 기술만을 이용해서 해결하려고 하는 개발자

이게 제일 문제라고 생각하는건 어떻게 해결된건지도 모르는데 해결됐고 성능 수치를 정확하게 측정해볼 수도 없을 것이다.

# 4.4 성능 안티패턴 카탈로그

증상과 현실들의 예시여서 스킵

# 4.5 인지 편향과 성능 테스트

안티패턴은 확증편향과 최신편향 두가지가 조합된 것이다.

각 편향들은 이중적이거나 상보적이다.

## 4.5.1 환원주의

시스템을 아주 작은 조각으로 나누어 그 구성 파트를 이해하면 전체 시스템도 다 이해할 수 있다는 분석주의적 사고방식이다.

파트를 이해하지 못하면 올바른 가정을 내릴 가능성도 작아진다는 편향적인 사고

→ 복잡한 시스템은 시스템 전체를 바라봐야 문제 원인을 찾을 수 있다.

## 4.5.2 확증 편향

성능면에서 중대한 문제를 초래하거나, 애플리케이션을 주관적으로 바라보게 한다.

테스트 셋을 부실하게 선택하거나, 테스트 결과를 통계적으로 건전하게 분석하지 않으면 확증 편향의 포로가 되기 쉽다.

이 현상은 강력한 동기부여되거나 감정 요소가 개입되기 때문에 거스르기가 어렵다.

## 4.5.3 행동 편향

시스템이 예상대로 작동하지 않는 상황 또는 아예 중단된 시간중에 발현되는 편향이다.

- 영향도를 분석하지 않고 공지 없이 인프라를 변경한 경우
- 시스템이 의존하는 라이브러리를 변경
- 연중 가장 업무가 빠듯한 날에 처음보는 버그나 경합조건이 발생

평소에 로깅과 모니터링을 꾸준히 하여 잘 가꾸어온 애플리케이션은 오류가 발생하면 명확하게 에러 메시지가 생성되기에 금새 원인을 찾아낼 수 있다.

## 4.5.4 위험 편향

개인적인 견해로는 레거시 애플리케이션을 만질 때 이 부분의 편향이 도드라질 것 같다.

이 편향은 애플리케이션 문제가 생겼을 때 제대로 학습하고 적절한 조치를 하지 못한 까닭에 더 고착화된다.

## 4.5.5 엘스버그 역설