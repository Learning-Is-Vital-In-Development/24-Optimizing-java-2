# 5장  - 마이크로벤치마킹과 통계

JVM은 자유분방한 특성 탓에 성능 수치를 다루기가 만만치 않다. 특히, 작은 자바 코드 한 조각의 성능을 정확히 측정하기란 매우 미묘하고 어렵다.

- **마이크로벤치마킹**

마이크로벤치마킹은 작은 코드 단위의 성능을 측정하는 방법입니다. 이는 특정 기능이나 작업 응답 시간을 측정하고 분석하여 성능 최적화를 위한 데이터를 제공합니다.

- **베어** **트랩**

"베어 트랩"은 프로그램이나 시스템의 성능 측정 시 흔히 발생하는 오해나 함정을 지칭하는 용어입니다. 이를 이해하고 피하는 것은 정확한 성능 측정과 최적화를 위해 중요합니다.

# 자바 성능 층정 기초

벤치마크란, 입출력을 지닌 일종의 ‘블랙 박스’와 같다. 가급적 시스템의 어느 한 곳만 변경하고 다른 외부 요인은 벤치마크 안에 두고 통제하면 좋다. 이상적으로는 시스템에서 가변적인 부분은 테스트간에 불변성을 유지해야 하지만 실제로 그렇게 운 좋은 경우는 드문 편이다. 

**자바 플랫폼을 벤치마크할 때에 자바 런타임의 정교함이 가장 문제인다.** JVM이 개발자가 작성한 코드에 적용하는 자동 최적화의 맥락에서 벤치마크를 과학적인 테스트로 바라보면 우리가 가진 선택지는 한정적이다. 애플리케이션 코드가 정말 정확히 투영된 성능 모델은 생성 하기도 어렵고 적용 범위가 한정된다. 

즉, 자바 코드 실행은 JIT 컴파일러, 메모리 관리, 그 밖의 자바 런타임이 제공하는 시스템과 완전히 떼어놓고 생각할 수 없다. 테스트 당시의 OS, 하드웨어, 런타임 조건등의 작용 또한 무시할 수 없다. 

이와 같은 여러 작용은 보다 **큰 단위로 처리하여 상쇄시킬 수 있으나 작은 규모로 마이크로벤치마크를 할때는 확실하게 떼어놓기 어렵다. 이것이 마이크로벤치마킹이 어려운 근본적인 이유이다.**

---

**벤치마킹의 문제점 몇가지**

- JVM 웜업
    
    JVM 웜업(warm-up)은 자바 가상 머신(JVM)이 프로그램을 최적화하기 위해 초기 실행 시간 동안 일어나는 현상을 가리킵니다. JVM은 프로그램을 실행할 때 몇 가지 최적화 기법을 사용하여 성능을 향상시키는데, 이러한 최적화는 일반적으로 프로그램을 처음 실행할 때 수행됩니다. 
    
    로딩, 링크, 초기화는 프로그램이 처음 실행될 때 발생하며, 이 과정은 JVM이 프로그램을 실행하는 동안 발생하는 초기 오버헤드입니다. 이후에는 JIT 컴파일러가 코드를 최적화하여 실행 속도를 향상시키지만, 초기 실행 시간 동안에는 이러한 최적화가 이루어지지 않을 수 있습니다.
    
    타이밍을 캡쳐(로깅)하기 전에 JVM이 가동 준비를 마칠 수 있게 웜엄 기간을 두는 것이 좋다. 타이밍 세부를 캡쳐하지 않은 상태로 벤치마크 대상 코드를 여러 번 반복 실행하는 식으로 JVM을 예열시킨다.
    
- GC
    
    타이밍 캡처 도중에 GC가 안 일어나게 설정한 다음 가동시키면 좋지만 가비지 수집은 원래 불확정적이어서 개발자가 어쩔 도리가 없다. GC가 일어날 가능성이 큰 시기에는 캡쳐하지 않는 게 그나마 최선이다. 
    
- 테스트 하려는 코드에서 생성된 결과를 실제로 사용하지 않는다.
    
    사실상 죽은 코드이므로 JIT 컴파일러가 이를 죽은 코드 경로로 식별하고 정작 우리가 벤치마크하려던 것을 최적화해버릴 가능성이 있다.
    

---

벤치마크 코드를 바로 잡는 일은 복잡하다. 자신이 프로파일링하려는 코드 외에 위에 설명한 모든 이슈들을 진지하게 고민하지 않으면 엉뚱한 벤치마크 결과를 얻게 될 것이다. 

해결방안은 두가지 이다.

1. 시스템 전체를 벤치마크한다. : 저수준 수치는 수집하지 않거나 무시한다. 전체 결과를 평균 내어 더 큰 규모의 유의미한 결과를 얻는다. 
2. 연관된 저수준의 결과를 의미있게 비교하기 위해 앞서 언급한 많은 문제들을 공통 프레임워크를 이용하여 처리한다. → JMH가 그러한 툴이다. 

# JMH 소개

- **마이크로 벤치마킹 대상으로 적합한 유스케이스를 분별하는 휴리스틱**
    
    벤치마킹하는 것은 몹시 어려울 뿐 아니라 베어트랩에 빠질 위험이 있다.
    
    자바 플랫폼은 천성이 동적이며 가비지 수집 및 공격적인 JIT 최적화 특성으로 성능을 가늠하기 어렵고 런타임 환경마다 성능 수치도 제각각이다. 
    
    하지만 어쩔 수 없이 코드 조각 하나를 직접 성능 분석해야 할 때가 있다. 일반적으로 저수준 분석이나 마이크로벤치마킹을 하는 유스케이스는 다음 세가지 이다.
    
    1. 사용 번위가 넓은 범용 라이브러리 코드를 개발한다.
    2. OpenJDK 또는 다른 자바 플랫폼 구현체를 개발한다.
    3. 지연에 극도로 민감함 코드를 개발한다.

### **JMH 프레임워크**

JMH는 자바를 비롯한 JVM을 타깃으로 하는 언어로 작성된 나노/마이크로/밀리/매크로 벤치마크를 제작, 실행, 분석하는 자바 도구이다.

JMH는 JVM을 빌드한 사람들이 직접 만든 프레임워크라서, JVM 버전별로 숨겨진 함정과 베어트랩을 피하는 방법을 누구보다 잘 알고 있으며 새로운 최적화 및 다른 외부 제어 변수들이 잘 관리되도록 OpenJDK의 개발 흐름을 잘 따라가는 프레임워크다.

벤치마크 프레임워크는 컴파일 타임에 벤치마크 내용울을 알 수 없으므로 동적이여야 한다. JMH는 벤치마크 코드에 어노테이션을 붙여서 자바 소스를 추가 생성하는 식으로 작동한다.

또한 유저 코드를 반복 호출할 경우, 루프 최적화를 수행할 수 있기때문에 추프 최적화에 걸리지 않을 정도로 조심스레 반복횟수를 설정한 루프 안에 감싸 넣는다. 

 

- **벤치마크 실행**
    
    : 필요한 아티팩트를 모두 내려받으면 벤치마크 메서드에 `@Benchmark` 를 붙인다.
    
    ```java
    public class MyBenchmark{
    
    	@Benchmark
    	public void testMethod(){
    		// 코드 스텁
    	}
    }
    ```
    
    : 벤츠 마크 실행을 설정하는 매개변수는 명령줄에 넣거나, mian() 메소드에 세팅한다.
    
    : 벤치마크 할 때 보통 데이터셋 생성 또는 성능 비교용 대조군에 필요한 조건을 세팅 등 몇가지 설정 작업이 필요하다.
    
    : JMH는 타겟 메소드의 결과가 사용되지 않아 삭제 대상으로 여겨지는 것을 방지하기 위해 벤치마크 메소드가 반환한 단일 결과값을 암묵적으로 (무시해도 좋을 정도의 성능 오버헤드를 갖는)*블랙홀*에 할당한다. 
    
    블랙홀은 네가지 장치를 이용해 테스트에 영향을 줄 수 있는 최적화로 부터 보호한다.
    
    - 런타임에 죽은 코드를 제거하는 최적화를 못하게 한다.
    - 반복되는 계산을 상수 폴딩하지 않게 만든다.
    - 값을 읽거나 쓰는 행위가 현재 캐시 라인에 영향을 미치는 공유현상 방지
    - 쓰기 장벽으로 부터의 보호
    
    스코프가 한정된 탓에 벤치마크가 과최적화되지 않게 만드는 장치들이다. 
    

# JVM 성능 통계

모든 측정에는 어느 정도 오차를 수반한다. 성능 분석시  흔히 맞닥뜨리는 두가지 주요 오차가 있다.

- **랜덤 오차**
    
    상관관계 없이 결과에 영향을 미친다. 
    
    원인을 알 수 없는 예기치 못한 환경상의 변화에서 일어나며 랜덤 오차의 근원은 오직 운영환경이다. 
    
    대부분 정규분포(가우시안 분포)에 따른다.
    
- **계통 오차**
    
    원인을 알 수 없는 요인이 상관관계  있는 형태로 측정에 영향을 미친다. **정밀도**는 높으나, **정확도**가 늦은 경우를 말한다.
    
    선형적으로 응답시간이 느려지는 패턴 (메모리 누수 혹은 리소스 점유 등으로 한정된 서버 리소스가 조금씩 소모되고 있는 경우 주로 나타나는 패턴), 일괄적으로 모든 케이스에 지연이 나타나는 패턴(테스트 설정의 오류로 발생한 전반적인 이슈)등의 예시가 있다.
    
- 허위 상관
    
    두 변수가 비슷하게 움직인다고  이들 사이에 연결고리가 있다고 볼 수는 없다.
    

---

**비정규 통계학**

비정규 통계학은 다양한 비정규 분포를 다루며, 그 중에서도 특히 꼬리가 두터운(tailed) 분포, 우상향(skewed) 분포, 이산(discrete) 분포 등을 다룹니다.

# 통계치 해석

일반적으로 측정값을 보다 유의미한 하위 구성 요소들로 분해하는 개념이 아주 유용하다. 분석자는 결과값을 보고 결론을 도출하기 전에 먼저 본인이 데이터 및 도메인을 충분히 이해해야한다.

통계학 및 분석 기법을 활용한 사례를 볼 수 있는 페이팔 기술팀 블로그를 추천한다.

- https://www.paypal-engineering.com/

---

# 마치며

- 유스케이스를 확실히 모르는 상태에서 마이크로벤치마킹을 하지 마라
- 그래도 마이크로벤치마킹을 해야한다면 JMH를 이용해라
- 얻을 결과를 가능한 많은 사람들과 공유하고 팀원들과 의논해라
- 항상 잘못될 가능성을 염두해두고 내 생각을 지속적으로 검증해라.
- 마이크로밴치마킹의 장점은 저수준 서브시스템이 유발한 고도로 동적인 움직임과 비정규 분포 양상을 명확하게 드러낸다.
