# 11. 자바언어의 성능향상기법
- 쓰레기같은 코드들도 운영계에서는 최적화로 인해서 잘 돌아가게된다.
- 네트워크 연결 -> I/O -> DB 등의 애플리케이션 외부 요인 다음으로 병목을 일으킬 공산이 가장 큰 부분이 바로 `코드 설계`입니다.
- 코드의 기본원칙을 알아보자
  - 데이터 저장시 어떤 옵션이 있는지
  - 자바 컬렉션 API가 지원하는 자료구조및 구현 세부를 꿰뚫고 있어야합니다.
  - 자료구조에 대한 조회 원리와 수정방법을 정확히 알고 자료구조를 선택해야합니다.

  - 도매인 객체가 무엇인지, 시스템 내부에서 도메인 객체의 수명이 어떠한지 아는지 알아야하고 가비지 수집에 대한 영향을 이해해야합니다.

## 11.1 컬렉션 최적화
- 순차 컨테이너: 수치 인덱스로 표기한 특정위치에 객체를 저장한다. (LIST)
- 연관 컨테이너: 객체 자체를 이용해 컬렉션 내부에 저장할 위치 결정 (HASHTABLE)
  - 기본 조건: 모든 객체는 hashcode() 와 equals() 메서드 구현이 필요하다.

## 11.2 List 최적화
- ArrayList와 LinkedList 두가지 형태로 나타냅니다.


### 11.2.1 ArrayList
- ArrayList는 고정 크기 배열에 기반한 리스트입니다.
- ArrayList는 처음에 빈 배열로 시작하고 첫 원소가 추가될 때 10 용량을 할당합니다.
- 초기용량값을 잘 정해서 추가적으로 용량 할당하는 사이클을 제거할 수 있습니다.

### 11.2.2 LinkedList
- 동적으로 증가하는 리스트
- 조회가 O(N) + 추가 O(1)

### 11.2.3 ArrayList vs LinkedList
- 리스트 끝에 원소를 삽입하는 작업은 ArrayList
- LinkedList 모두 일정한 시간이 소요됨
- 인덱스에 따른 원소 추가는 arrayList 한칸씩 다 땡겨야함
- 원소 삭제가 빈번하거나 추가가 빈번하면 LinkedList사용 아니면 ArrayList
- 하지만 랜덤 액세스가 잦은 경우 ArrayList 사용


### 11.3 Map 최적화
- 매핑이란 키와 연관된 값 사이의 관계 ( 연관 배열)
- 과학책에 나오는 hashtable을 구현한 개념입니다.
  - hash 키를 가지고 access
  - Static Class 로 Node를 가지고 있다.
- 버킷 엔트리를 리스트에 저장
- 값을 찾으려면 키 해시값을 계산하고 equals() 메서드로 리스트에서 해당 키를 찾는다.
- 동등성 기준으로 찾는 메커니즘으로 키 중복은 허용하지 않는다.
- Hashmap 용량은 현재 생성된 버킷 개수(16개 디폴트) + loadFactor는 버킷 용량을 2배로 증가시키는 한계치
- 용량을 2배 늘리고 데이터를 다시 배치하는 것을 재해시라고 부릅니다.
- initialCapacity와 loadFactor를 잘 설정해서 자동 재해시를 막는게 중요합니다.
- 순회시에 capacity에 따라 비용이 늘어나므로 잘 생각 해야합니다.
- 트리화도 성능에 영향을 주는 요인입니다. Treeify Threshold에 다 다르면 TreeNode로 바꿉니다. -> TreeMap처럼 작동
  - 순회에 유리하지만 노드가 2배더 커서 공간을 더 차지함
- LinkedHashMap
  - 삽입 순서이지만 액세스 순서로 바꿀 수 있습니다. 순서가 중요한 코드에서 많이 쓰이지만, Treemap과 같은 비용이 들지 않습니다.

### 11.3.2 TreeMap
- TreeMap은 레드-블랙 트리를 구현한 Map 입니다. 트리 균형을 한쪽으로 치우치는 현상을 방지한 트리
- TreeMap은 다양한 키가 필요할 때 유용하며 서브맵에 신속히 접근한다
- get, put, containsKey, remove 모두 log(n)
- 스트림이나 람다로 Map을 처리해야할 때, TreeMap을 사용하게 됩니다.
- 대부분은 HashMap이면 충분하다.

## 11.4 Set 최적화
- 세종류 set이 있고 hashset은 hashmap으로 구현됨
- Map과 동일함 -> 삽입,삭제, CONTAINS, O(1) 순회는 O(intialCapacity 와 loadFactor에 따라다름)

## 11.5 도메인 객체
- jmap -histo 로 자바 힙상태를 살펴 볼수 있고 도메인 객체의 메모리 누수 현상을 진단 할 수 있습니다.
- 가장 흔히 할당되는 자료 구조는 string, char, byte, collections
- jmap에서 누수되는 데이터는 비정상적으로 비대한 데이터 셋으로 나타냅니다.
- 애플리케이션에 속한 도메인 객체가 jmap 결과치의 상위 30위 정도 든다면 메모리 누수가 발생한 신호라고 볼수 있습니다.
- 알맞은 크기의 작업세트를 배정해야합니다

## 11.6 종료화 안하기
- finalize 메서드는 리소스를 관리하려고 만든 장치 하지만 파일 핸들을 열고 close() 함수를 호출하는 일을 잊어버리는 경우도 많다.
- 리소스 소유권을 객체 수명과 단단히 묶ㄴ는것이 타당합니다.
- 가비지 수집 중 즉시 회수되지 않고 종료화 대상으로 등록된 객체는 다음과 같이 수명이 연장됩니다.
  - 종료화가 가능한 객체는 큐로 이동한다.
  - 별도의 종료화 스레드가 큐를 비우고 객체마다 finalize 메서드를 실행한다.
  - finalize() 가 종료되면 객체는 다음 사이클에 진짜 수집될 준비를 마친다.
- 종료화된 객체는 한번의 gc사이클 더 보존됩니다.
- 자바 메모리 관리 서브시스템은 할당할 가용 메모리가 부족하면 가비지 수집기를 실행시키게 됩니다.
- 객체가 수집될 때에만 실행되는 finalize() 메서드 호출 시점 불분명
- 항상 리소스가 고갈될 위험에 노출됨

## 11.6.3 TRY-WITH-RESOURCES
- TRY FINALLY BLOCK을 생성
  - AUTOCLOSEABLE INTERFACE 구현된 객체만 리소스로 생성가능
  - NULL이 아니라면 CLOSE 처리(예외 발생 여부와 상관없이 실행됨)
  - JDBC에서 사용함

## 11.7 메서드 핸들
- invokedynamic 명령어는 자바 7부터 선보인 기능
- invokedynamic 호출부가 실제로 어느 메서드를 호출할지 런타임 전까지 결정 X
- 핵심은 메서드 핸들 -> invokedynamic 호출부에 의해 호출되는 메서드를 나타낸 객체
- 리플렉션과 개념이 어느정도 빗비슷함
- method handle은 실행가능한 메서드의 레퍼런스를 직접 반영 가능하다.
- 하부 메서드를 실행 가능한 메서드가 메서드 핸들 객체에 내장 되어 있다.
