# 11장 - 자바 언어의 성능 향상 기법

네트워크 연결, IO, DB 등의 애플리케이션 외부 요인 다음으로 병목을 일으킬 공산이 가장 큰 부분은 코드 설계이다.

성능에 민감한 개발자가 반드시 마음에 새겨야할 원칙 

- 데이터를 애플리케이션에 어떻게 저장할 지
- 도메인 객체의 수명이 어떤지

## 컬렉션 최적화

: 자료구조가 어떤 원리로 조회되고 수정되는지 모른 채 자료 구조를 선택하는 것은 위험한 일이다.

: 대부분 프로그래밍 언어 라이브러리는 최소한 두가지 컨테이너를 제공한다.

- 순차 컨테이너 : 수치 인덱스로 표기한 특정 위치에 객체를 저장 (array, list, deque,..)
- 연관 컨테이너 : 객체 자체를 이용해 컬렉션 내부에 저장할 위치를 결정 (set, map,..)

: 컨테이너에 저장되는 건 객체 자신이 아니라, 객체를 가르키는 래퍼런스이다. 그러므로 C/C++ 형식의 배열이나 벡터를 사용하는 것만큼 성능을 얻을 수 없다. 

: 자바는 메모리 서브시스템이 알아서 가비지 수집을 해주는 대신, 저수준의 메모리 제어를 포기할 수 밖에 없다.

## List 최적화

**ArrayList**

: 고정 크기 배열에 기반한 리스트. 배열이 꽉 차면 더 큰 배열을 새로 할당한 다음 기존값을 복사한다.

→ 성능에 민감한 경우 크기 조정 작업 비용과 유연성(얼마나 더 커질지)를 잘 저울질 해야한다.

처음 빈 배열로 시작하고 처음 원소가 저장될때 용량 10인 기반 내열을 할당한다.

초기값을 생성자에 전달하면 크기 조정을 하지 않아도 되기때문에 재할당 비용이 감소하여 성능에 더 낫다.

**LinkedList**

: 동적으로 증가하는 리스트. 이중 연결 리스트로 구현된다.

**성능 차이**

두개의 구현체 중 어떤 것을 쓸지는 데이터 접근/수정 패턴에 따라 다른다.

리스트 끝에 원소를 삽입 : **ArrayList = LinkedList**

특정 인덱스에 원소를 추가시 : **ArrayList < LinkedList**

리스트의 랜덤 액세스 : **ArrayList > LinkedList**

→ LinkedList의 고유 기증이 꼭 필요한게 아니라면, 특히 랜덤 엑세스가 필요한 알고리즘을 구사할때 ArrayList를 권장한다. ArrayList는 가급적 크기를 지정해 다시 조정하는 일이 없도록 하는 것이 좋다.

## Map 최적화

: 키와 연관된 값 사이의 관계를 매칭한 자료구조. 키/값 모두 반드시 참조형이여야한다.

**HashMap** 
HashTable과 같은 기능을 제공하지만 HashMap은 해시 보조 함수를 사용하여 HashTable보다 충돌이 덜 발생하여 상대적으로 성능 이점이 있다.

값을 찾으려면 키 해시값을 계산하고 리스트에서 해당 키를 찾는다.

: 자바7부터 ‘해시 충돌’을 막기 위해  index 값 분포가 가급적 균등할 수 있도록 해시 보조 함수에 상위 비트값이 해시 버킷의 인덱스 값을 계산할때 반영되도록 적용되었다. 이렇게 하면 인덱스 계산시 상위비트가 누락되어도 *눈사태 효과*를 막을 수 있다.

: HasgMap은 생성된 버킷 개수(default 16)를 자동 증가(2배) 시켜 데이터를 재배치하는 과정을 수행한다. (해시 버킷 동적 확장, 재해시)

→ 해시 버킷의 개수가 적다면 메모리를 아낄 수 있지만 해시 충돌이 잘 일어나 성능 저하가 발생한다. 그래서 일정 개수이상 버킷이 차면 재해시를 실행한다.

→ 최대원소 개수를 `loadFactor`로 나눈 값을 `intialCapacity`로 설정하면 재해시가 발생하지 않는다. 두개의 매개 변수가 HashMap의 성능에 가장 큰 영향을 미치며 ArrayList와 같이 저장할 데이터의 양을 대략적으로 알고 있다면 미리 설정하여 재해시를 막을 수 있다.

: Java HashMap에서 사용하는 방식은 Separate Channing이다. 실제 해시 값은 균등 분포가 아닐뿐더러, 설사 균등 분포를 따른다고 하더라도 일부 해시 버킷 몇 개에 데이터가 집중될 수 있다. 그래서 데이터의 개수가 일정 이상일 때에는 링크드 리스트 대신 트리를 사용하는 것이 성능상 이점이 있다.

→ 최근 HashMap에는 새로운 장치가 달려 하나의 버킷에 `TREEIFY_THRESHOLD`에 설정한 개수만큼 모이면 버킷을 TreeNode로 변경한다. (Java 8 HashMap의 `TREEIFY_THRESHOLD`는 8)

→ 아예 처음부터 TreeNode를 사용하지 않는 이유는 TreeNode는 리스트 노드보다 약 2배 더 크기때문에 공간을 더 차지한다.

HashMap에 성능저하가 발생한다면 HashMap의 해시함수, initalCapacity, loadFactor 설정을 다시 한번 검토해보는 것이 좋다.

**LinedHashMap**

HashMap의 서브클래스로, 이중 연결 리스트를 사용해 원소워 삽입 순서를 관리한다.

Map을 사용할때 대부분 순서가 중요하지 않기때문에 써야할 일이 비교적 드물다.

**TreeMap**

레드-블랙 트리를 구현한 Map. 트리의 균형이 한쪽으로 치우치는 현상을 방지한다.

**MultiMap**

없어요.

Map<K, List<V>> 형태로 충분히 구현가능하다.

## Set 최적화

중복값을 허용하지 않는 자료구조.

세 종류의 Set이 있고 성능에 관해서 Map과 비슷하게 고려하면된다. 실제로 HashSet은 HashMap으로 구현되어 있다.

**HashMap**

HashSet은 내부적으로 HashMap의 key에 원소, 값은 PRESENT라든 더미 객체로 구성된다.

PRESENT의 오버헤드는 무시할 정도이다.

**LinkedHashMap**

protected 생성자에서 LinkedHashMap 객체를 받아서 삽입 순서를 유지한다.

삽입, 삭제, contains 작업 복잡도는 O(1)이고 순회비용은 `loadFactor`, `intialCapacity`에 따라 달라진다.

**TreeSet**

Comprator에 정의한 순서대로 키 순서를 유지한다.

삽입/삭제 복잡도는 log(n)이며 원소의 순서가 유지된다.

## 도메인 최적화

도메인 객체는 애플리케이션에 유의미한 비즈니스 컨셉트를 나타낸 코드이다.

도메인 객체는 대부분 타입 간에 연관되어 존재한다.

**자바 힙의 기본 팩트**

- 가장 흔히 할당되는 자료구조는 String, char 배열, byte 배열, 컬렉션 인스턴스이다.
- jmap에서 누수 되는 데이터는 비정상적으로 비대한 데이터셋을 나타낸다.

→ 메모리 점유량과 인스턴스 개수는 보통 이러한 코어JDK에 있는 자료구조가 상위권을 형성한다. 그런데 애플리케이션에 속한 도메인 객체가 jmap 결과치의 상위 30위 정도안에 든다면 메모리 누수가 발생한 신호라고 볼 수 있다.

**‘전체 세대’ 효과**

특정 타입의 객체가 응당 수집돼야 할 시점에 수집되지 않을 경우, 별의별 세대 카운트 값을 지닌 채 테뉴어드 세대까지 살아남을 것이다. 

→ 대처하기 위해서는 도메인 객체에 대응되는 데이터셋의 크기를 살피고 그 수치가 온동한지, 그리고 작업세트에 존재하는 도메인 객체 수가 예상 범위 내에 드는지 확인

→ 단명 도메인 객체 역시 부유 가비지 문제를 일으키는 또 다른 원인이 될 가능성이 있다.

성능을 중요시하는 개발자라면 도메인 객체의 도메인을 인식하고 그에 알맞는 크기의 작업 세트가 배정되도록 해야한다.

## 종료화 안 하기

자바의 finalize() 메서드는 C++의 리소스 획득은 초기화 패턴과 마찬가지로 자동으로 리소스를 관리하려고 만든 장치이다.

기본 유스케이스는 어떤 객체가 생성되면 이 객체는 리소스를 소유하고 객체가 살아 있는 한 소유권이 지속된다. 

이때 리소스 소유권을 객체 수명과 묶는 것은 타당하다. 객체가 지닌 리소스를 자동으로 없애는 일은 프로그래머가 아닌 플랫폼의 몫이다.

자바는 어떤 객체가 더 이상 자신을 참조하지 않는다고 가비지 수집기가 판단하면 그 객체에 있는 finalize() 메소드를 호출한다. 

→ 하지만 이 메서드를 오버라이드해서 특정한 로직을 부여한다면, 가비지 수집기가 특별하게 처리하게 된다. 가비지 수집 중 즉시 회수되지 않고 종료화 대상으로 등록된 객체는 다음과 같은 수명 연장을 한다.

1. 종료화가 가능한 객체는 큐로 이동한다.
2. 애플리케이션 스레드 재시작 후, 별도의 종료화 스레드가 큐를 비우고 각 객체마다 finalize() 메서드를 실행한다.
3. finalize()가 종료되면 객체는 다음 사이클에 진짜 수집될 준비를 마친다.

## 메서드 핸들

invokeddynamic 명령어는 호출부에서 실행할 메서드를 아주 유연하게 결정할 수 있게 한다.

핵심 포린트는 invokedbynamic 호출부가 실제로 어느 메서드를 호출할지 런타임 전따지 결정되지 않는다는 점이다. 

이때 invokedynamic 호출부에 의해 호출되는 메서드를 나낸 객체를 **메서드 핸들**이라고 한다.

런타임시 메서드를 호출할때 수신자와 method 변수가 안맞거나 매개변수 목록에 오류가 생겨 런타임에 실패할 가능성이 있다.

→ 메서드 핸들 두 부분으로 나누어 호출한다. 메서드 핸들을 룩업하고 그 다음에 호출한다.

메서드 핸들은 안정된 불변 객체라서 나중에 쓸 목적으로 보관, 캐시하기가 쉽다. 메서드 핸들 API는 룩업 컨텍스트하는 방식으로 접근하여 이 메서드가 반환한 불변 객체에 컨텍스트 객체를 생성한 시점에 액세스 가능한 메서드와 필드를 기록한 상태 정보를 가진다. 따라소 저장했다가 나중에 써도된다. 

→ 이러한 유연성 덕분에 클래스에 있는 프라이빗 메서드를 선택적으로 액세스 할 수 있게 되었다.

리플랙션과 비슷해보이지만 리플랙션은 자바의 안전한 액세스 제어의 허점을 노출시키기때문에 좋은 패턴이 아니다.

만약 룩업 컨텍스트로 안 보이는 메서드에 액세스 하려고하면 illegalAccessException이 발생하기때문에 리플렉션돠 달리 프로그래머가 이러한 액세스 체크 로직을 해제하는 것은 불가능하다. 

invoke() 호출이 모든 인수를 두루 받아들이는 만능 호출인 대신, 런타임에 호출돼야 할 메서드의 예상 시그니처를 기술하기때문에 리플렉션과는 모양새가 다르다.
