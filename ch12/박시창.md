# 12.동시성능기법
- 순차형 코딩 해왔다
- 무어의 법칙으로 프로그램 빨라져왔다.
- 멀티 코어 프로세서가 일반화됐다.
- jit 컴파일 철머 여러 프로세스 코어를 활용할 수 있는 VM스레드를 활용할 수 있다.
- Java Concurrency In Practice 책을 참고해라

## 12.1 병렬성
- 태스크가 병렬 실행 가능 할때, 반드시 순차 실행(S)해야하는 파트로 구성됨
- T(N) = S(순차 실행 시간) + (T(총실행 시간) - S) / N
- 프로세서 무한 증가 시켜도 총 소요 시간은 순차 작업 시간 이상 줄일수 없다.
- 아무리 코어 늘려도 20배 이상 속도 증가 X
- 데이터 공유 없이 동시처리하면 속도 개선
- 데이터 공유 필요하면 일부 태스크 순차 처리 필요하고 오버헤드 생김
- 상태 공유 하게 되면 정교한 보호 및 제어 장치가 필요합니다. -> JMM이라는 메모리 보증 세트 제공

## 12.1.1 자바 동시성 기초
- 카운터 증가시키는 코드
- 락으로 적절히 보호되지 않은 필드 수정 결과 소실 됨
  - OS 스레드 순서 보장 전혀되지 않음
  - 각 스레드는 메서드 개별 진입시 전용 평가 스택을 소유 -> 필드 작업 간섭 (객체의 필드는 힙에 위치 및 모든 쓰레드가 공유)
  - VOLATILE 설정하면 연산할 수 있어 보이지만 업데이트 소실 문제는 계속 일어난다.
  - Synchronized를 사용하면 업데이트 제어할 수 있다.
    - 더느려질수도;;
  - jvm의 저수준 메모리 모델과 동시 애플리케이션의 실제적 기법을 익혀야함
## 12.2 JMM의 이해
다음의 답을 해준다.
- 두 코어가 같은 데이터를 액세스하면 어떻게 되는가?
- 언제 두코어가 같은 데이터를 바라본다고 장담할 수 있는가?
- 메모리 캐시는 두질문의 답에 어떤 영향을 미치는가?

- JMM은 순서에 관한 보장 + 여러 스레드에 대한 업데이트 가시성 보장을 약속해준다
- 두가지 메모리 모델이 있다
  - 강한 메모리 모델
    - 전체 코어가 항상 같은 값 바라봄
  - 약한 메모리 모델
    - 코어마다 다른 값을 바라 볼수 있고 특별한 캐시 규칙이 있다.
- 강한 메모리 모델은 메모리를 후기록하는것이나 마찬가지이다.
  - 캐시 무효화 알림이 메모리 버스를 잠식하고 메인 메모리 전송률은 급락할것이다.
  - 멀티코어 체제에 안맞는다.
- JMM은 약한 메모리 모델이다.
  - HAPPENS BEFORE
    - 한 이벤트는 무조건 다른 이벤트보다 먼저 발생한다.
  - Synchronizes with
    - 이벤트가 객체 뷰를 메인 메모리와 동기화 시킨다.
  - As-If-Serial (순차적인것처럼)
    - 실행 스레드 밖에서는 명령어가 순차 실행된거 처럼 보인다.
  - Release Before Acquire(획득하기전에 해제)
    - 한 스레드에 걸린 락을 다른 스레드가 획득하기전에 해제한다.
  - 동기화를 통한 락킹은 가변상태를 공유하는 가장 중요한 기법입니다.
  - 이 때문에 jvm에는 저수준 메모리 액세스를 감싸놓은 구현 코드가 상당히 많습니다.

  - synchronized 키워드가 나타내는 의미는 분명
    - 모니터를 장악한 스레드의 로컬 뷰가 메인 메모리와 동기화
  - JMM은 동기화되지 않은 액세스에 대해서 할말이 없습니다.
    - 한 스레드가 변경한 부분을 다른 스레드가 언제 바라볼 수 있는지 전혀 보장하지 않음
    - 해당 보장이 필요하면 쓰기 애세스를 동기화 블록으로 감싸서 메모리에 후기록 해야됨
  - 동기화 블록은 스레드가 반드시 동기를 맞춰야 할 접점에 해당, 동기화 메서드/블록이 시작되기 전에 완료되어야할 블록으로 정의
  - synchronized 락의 한계점 
    - 락이 걸린 객체에서 일어나는 동기화 작업 모두 균등하게 취급
    - 락 획득 해제는 반드시 메서드 수준이나 메서드 내부의 동기화 블록에서 이뤄져야한다.
    - 락을 얻지 못한 스레드는 블로킹 된다
    - 읽기 작업에 synhronized를 걸지 않으면 다른 스레드에서 업데이트 내용을 바라볼 수 없다.
  - gee.cs.oswego.edu/dl/jmm/cookbook.html 확인
  - 자바 메모리 모델 유형 자세히 살펴보기 -> jmm 추가 해설 제공
## 12.3 동시성 라이브러리 구축
- java util concurrent 패키지는 멀티 스레드 애플리케이션을 자바로 더 쉽게 개발하게 도와줌
- 이 라이브러리 구성요소들
  - 락, 세마포어 (semaphore)
  - 아토믹스 (atomics)
  - 블로킹 큐
  - 래치
  - 실행자 (executor)
- ## 12.3.1 Unsafe

JVM의 표준 로직을 무너뜨리는 Unsafe는 모든 프레임워크의 구현 핵심부를 차지합니다.

- 객체를 할당하지만 생성자 실행 x
- 원메모리에 액세스하고 포인터 수준의 연산을 한다.
- 프로세스별 하드웨어 특성을 이용한다.

고프레임워크 기능을 구현 가능

1. 신속한 직렬화
2. 스레드 안전한 네이티브 메모리 액세스
3. 아토믹 메모리 연산
4. 커스텀 메모리 펜스
5. 네이티브 코드와 상호작용
6. 배열 원소에 volatile 하게 액세스

## 12.3.2 아토믹스 CAS

아토믹스는 값을 더하고 복합 연산하고 GET으로 결과값을 반환받습니다.

아토믹스는 volatile의 확장판입니다.

상태 의존적 업데이트를 안전하게 수행할 수 있습니다

AtomicInteger는 Integer를 상속한 클래스가 아닙니다.

```jsx
public class AtomicInteger extends Number {
	private volatile int value;
	
	private static final Unsafe unsafe = Unsafe.getUnsafe(); // Unsafe.compareAndSwap 사용 업데이트
	valueOffset = unsafe.objectFieldOffset(
			AtomicIntegerExample.class.getDeclaredField("value")
		)
	
	public final int get() {
		return value;
	}
	
	
	public final int getAndSet(int newValue){
		return unsafe.getAndSetInt(this, valueOffset, newValue);
	}
	
```

```jsx
Unsafe 코드

public final int getAndSetInt(Object o, long offset, int newValue){
	int v;
	do {
	
		v - getIntVolatile(o, offset);
	} while (!compareAndSwapInt(o, offset, v, newValue);
	return v;
}

public final native bollean compareAndSwapInt()
```

- 아토믹은 락프리해서 데드락 있을 수 없다.
- 비교후 업데이트 하는 작업이 실패할 경우 대비해서 내부적인 재시도 루프 동반
- 성능을 고려할때, 처리율을 높은 수준을 유지하기 위해 경합 수준 잘 모니터링 해야한다.
- 저수준 하드웨어 명령어에 액세스할 수 있는 Unsafe를 사용하지 않고는 아토믹 클래스가 추구하는 취지를 살릴 길이 없다.

### 12.3.3 락과 스핀락

- 인트린직 락은 유저코드에서 os 호출함
- 경합 중인 리소스가 짧은 시간동안만 사용할 경우 막대한 오버헤드가 생깁니다. -> OS를 이용해 스레드가 무한정 기다리게됨
  - 블로킹된 스레드에서 락을 손에 넣을 때까지 CPU를 태워가며 계속 재시도하는 편이 효율적입니다.
- 이런 기법을 스핀락이라고 합니다.
- 최신 시스템들은 CAS로 스핀락을 구현합니다.

--- 아토믹 클래스와 단순 락을 구현하는데 사용하는 저수준 기법 소개 
### 12.4 동시 라이브러리 정리
- java 5 부터 락 인터페이스가 java.util.concurrent.locks.Lock에 추가됐습니다.
- 인터페이스를 이용하면 인트린직 락보다 더많은 일 가능하다.
- `lock` 기존 방식대로 락을 획득하고 락을 사용할 수 있을때까지 블로킹
- `new Condition` 락 주위에 조건을 설정해 좀더 유연하게 락 활용
- `tryLock` 락을 획득하려고 시도 (타임아웃)
- ` unlock` 라긍ㄹ 해제
- ReentrantLock은 Lock의 주요 구현체로 내부적으로 int 값으로 compareAndSwap을 합니다. 
  - 경합만없으면 락 획득 과정이 락 프리합니다.
- 스레드가 동일한 락을 다시 획득하는 것을 재진입 락킹이라고 합니다.
  - 스레드가 스스로를 블로킹 하는 현상을 방지할 수 있습니다.
  - 최신 애플리케이션에서는 재진입 라킹이 적용 되어 있습니다.
- 해당 락은 LockSupport 클래스를 이용하는데 스레드이ㅔ게 퍼밋 발행해줍니다.
  - park, unpark를 사용합니다.

### 12.4.2 읽기/쓰기 락
- 기존 synchronized 나 ReentrantLock을 이용하면 한가지 락 정책을 따를 수 밖에 없습니다.
- 쓰기와 읽기 스레드에 달려드는 상황에서 블로킹하느라 불필요한 시간이 낭비가 됩니다.
- 이때 ReentrantReadWriteLock 클래스의 ReadLock과 WriteLock을 활용해서 블로킹을 처리할 숭있습니다.
  - 동시 컬렉션 정도면 합리적인 추상화로 볼 수 있고 스레드 핫 성능도 훨 씬 좋아집니다.
### 12.4.3 세마포어
- 세마포어는 DB 접속 객체등 여러 리소스의 액세스를 허용하는 기술을 제공합니다.
- 최대 O개의 객체에 대해서 액세스를 허용한다 로 퍼밋으로 액세스 제어합니다.
- 세마 포어는 비소유 스레드도 해제할 수 있다는 점이 다릅니다.
- 여러 퍼밋을 획득/해제할 수 잇는 능력입니다.
- 공정 모드는 필수 입니다.

### 12.4.4 동시 컬렉션
- Map 구현채(ConcurrentHashMap)은 버킷 또는 세그먼트 로 분할된 구조를 활용해서 실질적 성능 개선 효과를 얻음
- 각 세그먼트 마다 자체 락킹 정책을 걸고 락을 걸지 않은 읽기 스레드는 put, remove 작업을하고 완료된 업데이트는 happens before 에 따라 읽는다.
- 이터레이터는 일종의 스냅샷으로 ConcurrentModifcation 에러가 뜨지 않는다.

### 12.4.5 래치와 베리어
- 태스크#1 -> 태스크#2 -> 태스크#3 순서로 진행되는것이 이상적이면 래치를 쓰기에 좋은 경우이다.
- 
