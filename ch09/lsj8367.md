# 9장. JVM의 코드 실행

JVM이 제공하는 가장 중요한 서비스는 메모리 관리와 사용하기 쉬운 애플리케이션 코드 실행 컨테이너

JVM 인터프리터는 스택 머신 처럼 작동하기에 물리적 CPU와 다르게 계산 결과를 바로 저장하는 레지스터는 없다.

> JVM이 데이터를 담아놓는 곳
> 
- 평가 스택
    - 메소드별 하나씩 생성
- 로컬변수
    - 결과 임시 저장(특정 메소드별 존재)
- 객체힙
    - 메소드끼리 or 스레드끼리 공유

JVM에서 각 스택 머신 작업코드(옵코드)는 1바이트로 나타냄

0~255까지 지정 가능하고, 약 200개를 사용함.

바이트코드 종류

- 로드/스토어
    - 상수풀 데이터로드
    - 스택 상단을 힙에 있는 객체 필드에 저장
- 산술
    - 기본형에만 적용되고, 스택기반으로 연산 수행
- 흐름제어
    - for, if, while 등의 루프, 분기문
- 메소드 호출
    - 새 메소드로 제어권을 넘기는 장치
    - 가장 중요하다
- 플랫폼
    - 객체별 힙 저장 공간 새로 할당
    - 고유락 제어

JVM 애플리케이션 스레드 1개 = OS 스레드 1개

인터프리티드 메소드를 실행하는 스레드에 대해 옵코드가 디스패치되는 시점에 애플리케이션 스레드가 실행하는 것은 유저 코드가 아니라 JVM 인터프리터 코드이다.

## 핫스팟

상용 제품급 JVM이자 완전한 구현체

템플릿 인터프리터라서 시작할 때마다 동적으로 인터프리터를 구축한다.

## AOT vs JIT

### AOT 컴파일

C/C++ 에서 익숙한 개념

소스 코드를 컴파일러에 넣고 바로 실행 가능한 기계어를 뽑아낸다.

목표 - 프로그램을 실행할 플랫폼과 프로세서 아키텍처에 딱 맞는 실행 코드를 얻는 것.

문제 - CPU 기능을 최대한 활용하지 못하고, 성능 향상의 숙제가 항상 존재함.

AOT는 특정 프로세서에서만 실행 가능한 코드가 만들어지는데, 이 때 성능이 극도로 중요한 곳에서는 유용한 기법이 될 것이지만, 확장성이 떨어진다.

### JIT 컴파일

런타임에 프로그램을 최적화하여 기계어로 변환

**대부분의 JVM이 이 방식으로 작동됨.**

애플리케이션을 실행할 때 마다 성능이 편차를 보여준다.

VM이 꺼지면 프로파일링 정보를 전부 폐기하고 새로 다시 만든다.

## 핫스팟 JIT 컴파일

핫스팟의 기본 컴파일 단위는 전체 메소드이다.

한 메소드에 해당하는 바이트코드는 한꺼번에 네이티브 코드로 컴파일된다.

핫 루프를 온스택 치환하는 기법을 이용해 컴파일 하는 기능도 지원한다.

핫스팟 = 멀티스레드 C++

OS관점에선 하나의 멀티스레드 애플리케이션 일부이고, 싱글 스레드 자바 애플리케이션이어도 결국 VM 스레드와 함께 실행되는 구조이다.

### 핫스팟 내부 컴파일러

C1, C2 두가지 컴파일러가 존재하며

C1은 클라이언트 컴파일러, C2는 서버 컴파일러라고 부르기도 한다. (요즘은 구분하는 기준이 뚜렷하진 않다)

둘다 메소드 호출 횟수에 따라 컴파일이 트리거링 된다.

호출 횟수가 한계치에 다다르면 VM이 알림을 받아 메소드를 컴파일 큐에 넣는다.

C1은 C2보다 컴파일 시간이 짧고 단순하기에 C2처럼 풀 최적화는 수행하지 않는다.

> 공통 기법
> 

변수를 일체 재할당하지 않는 코드로 변환하는 단일 정적 할당을 사용

> 단계별 컴파일
> 
- 레벨0
    - 인터프리터
- 레벨1
    - C1 - 풀 최적화(프로파일링 없음)
- 레벨2
    - C1 - 호출 카운터 + 백엣지 카운터
- 레벨3
    - C1 - 풀 프로파일링
- 레벨4
    - C2

단계별 컴파일은 디폴트이기에 성능 튜닝 시 이 부분을 조정할 일이 거의 없다.

## 코드캐시

JIT 컴파일된 코드는 코드캐시 메모리 영역에 저장된다.

인터프리터 부속과 VM 자체 네이티브 코드가 같이 들어있다.

VM 시작 시 코드 캐시는 설정된 값으로 최대 크기가 고정되어 확장이 불가능하다.

코드 캐시가 꽉찼을 때 JIT 컴파일이 더이상 되지 않고 컴파일이 안된 코드는 인터프리터에서만 실행된다.

미할당 영역과 프리블록 연결 리스트를 담은 힙으로 구현됨.

블록 재활용은 스위퍼라는 프로세스가 담당한다.

> 네이티브 코드가 코드 캐시에서 제거되는 경우
> 
- (추측성 최적화를 적용한 결과 틀린 것으로 판명되어) 역최적화 될 때
- 다른 컴파일 버전으로 교체됐을 때 (단계별 컴파일)
- 메소드를 지닌 클래스가 언로딩될 때

메모리 블록을 재배치하지 않는 가비지 컬렉터에서는 단편화가 불가피하고 코드 캐시도 예외가 아니다.

### JIT 튜닝법

1. PrintCompilation 스위치를 켜고 애플리케이션 실행
2. 어느 메소드가 컴파일 됐는지 기록된 로그 수집
3. ReservedCodeCacheSize 를 통해 코드캐시 늘림
4. 애플리케이션 재실행
5. 확장된 캐시에서 컴파일드 메소드를 살펴본다

성능 엔지니어는 JIT 컴파일에 내재된 불확정성을 고려해야 한다.