# 9. JVM 코드실행
- JVM의 코어 기능은 메모리 관리와 코드 실행 컨테이너다.
- 인터프리터로 자바 바이트코드를 실행하는환경은 기계어 직접 실행보다 성능이 떨어진다.
- 동적 컴파일 기능, JIT을 이용해서 이 문제를 해결한다.
- JIT 컴파일 기법은 실행 중인 메서드를 지켜보고 있다가 직접 실행 가능한 코드로 컴파일할 메서드를 분별하는 메커니즘이다.
  - 바이트 코드 해석
  - 프로파일 기반 최적화의 기초 개념
  - 코드 캐시 및 핫스팟 컴파일 서브시스템
  - 최적화를 어떻게 진행할지
    - 컴파일드 메서드 생성원리
    - 튜닝 방식
## 9.1 바이트 코드 해석
- JVM 인터프리터는 스택머신처럼 작동, 물리적 CPU와는 달리 레지스터는 없다.
- 작업할 값을 평가 스택에 놓고 스택 머신 명령어로 스택 최상단에 위치한 값을 변환
- 데이터 공간
  - 평가 스택: 메서드별 하나씩 생성
  - 로컬 변수: 결과 임시 저장
  - 객체 힙: 메서드 끼리 스레드끼리 공유
### 9.1.1 JVM 바이트 코드 개요
- 작업 코드는 1바이트로 나타냄
- 스택 상단에 위치한 두값의 기본형을 구분할 수 있게 표기
- IADD OR DADD (int 형 vs DOUBLE형)
- store 패밀리는 dstorem astore 로 double 형, 참조형이 있습니다.
- jvm은 빅엔디언 리틀엔디언 하드웨어 아키텍쳐 모두 바이트 코드 변경없이 실행 가능하다.
- load같은 옵코드 군에는 단축형이 있어서 인수 생략하고 클래스 파일의 인수 바이트 공간을 절약가능하다.
- this(현객체) alod_0 같은 명령어는 자주쓰여서 클래스 파일 크기 줄어든다.
- 자바 플랫폼 초기에는 클래스파일을 14.4kbps 모뎀을 통해 내려받아야되서 압축이 중요 이슈였다.

### 9.2 로드/스토어 
- 스택에 데이터를 넣고 빼는 옵코드
  - 상수 풀에서 데이터를 로드하거나 스택 상단을 힙에 있는 객체 필드에 저장하는 작업
  - load store
- ldc는 클래스의 상수풀에 있는 상수 로드
- const는 매개변수 없이 aconst_null 형태로 진짜 상수만 로드하는 옵코드

### 9.2 산술
- add
- sub
- div
- mul
- (cast)
- 기본형에 적용되며 스태 기반 연산 수행

### 9.3 흐름 제어 카테고리
- if
- goto
- 흐름을 제어하는 바이트코드

### 9.4 메서드 호출 바이트 코드
- 프로그램에서 새 메서드로 제어권을 넘기는 유일한 장치
- 지역 흐름 제어와 다른 메서드로 제어권을 넘기는 행위를 구분
- invokevirtual -> 메서드를 가상 디스패치를 통해 호출
- invokespecial -> 메서드를 특별한 디스패치를 통해 호출
- invokeinterface -> 인퍼에시ㅡ 오프셋 룩업을 이용해 인터페이스 메서드 호출
- invokestatic -> 정적 메서드 호출
- invokedynamic -> 호출해서 실행할 메서드를 동젖ㄱ으로 찾기


- call site (호출부) 는 메서드 내부에서 다른 메서드(callee)를 호출한 지점
- 비정적 메서드 호출의 경우, 어느 객체의 메서드인지 찾아야하는데 이런 객체를 수신자(receiver obj)라고 합니다.
- 인스턴스 메서드 호출은 invokevirtual
- 자바 인터페이스 메서드 호출 invokeinterface
- 컴파일 타임에 디스패치할 메서드를 특정할 수 있는 경우 (private or superclass ) invokespecial로 컴파일
- invokedynamic은 람다 같은 친구를 지원한다.
- invokedynamic 명령어에 의해 호출 되는 플랫폼 팩토리 메서드가 생성합니다.
- 클래스의 상수 풀에서 확장된 엔트리를 참조하여 런타임에 동적 호출 가능
- 플랫폼 옵코드 
  - 객체별로 힙 저장공간을 새로 할당
  - 고유락을 다루는 명령어
    - monitorenter
    - monitorexit
    - newarray
      - 할당할 배열길이가 스택 상단에 놓여진다.
    - new
    - anewarray
- 바이트코드는 구현 복잡도에 따라 대단위 바이트 코드와 소단위 바이트코드로 구분됨
  - 메서드 디스패치가 필요한 작업은 대단위 연산이 핫스팟 vm을 다시 호출한다.
- JVM애플리케이션 스레드 하나하나가 진짜 OS 스레드
  - JVM이 어떤 관리 작업을 수행하고 내부상태를 일관되게 유지하는 지점을 세이프포인트라고함
  - 객체 그래프가 들어 있음
  - 바이트 코드 사이사이가 단순한 세이프 포인트로 사용될 수 있음


### 9.2 AOT와 JIT 컴파일

### 9.2.1 AOT 컴파일
- 소스 코드를 컴파일러에 넣고 실행가능한 기계어로 뽑아내는것
- AOT는 프로세서 아키텍쳐와 실행한 플랫폼에 맞는 실행코드를 얻는것
- AOT 컴파일하게되면 사용가능한 프로세서 기능에 대해서 가장 보수적인 선택하게 되고 성능 향상 힘듬


### 9.2.2 JIT 컴파일
- JIT 컴파일은 런타임에 프로그램을 고도로 최저고하한 기계어로 변환하는 기법
- 프로그램의 런타임 실행 저보를 수집해서 어느부분을 최적화해야할지 프로파일을 만들어 결정하게됨
- 바이트 코드를 네이티브 코드로 컴파일하는 비용은 런타임에 지불됩니다.
- 프로파일링 서브시스템은 어느 메서드가 실행 중인지 추적합니다.
- 컴파일 하기 적정 한계치를 넘어선 메서드가 발견되면 컴파일 스레드를 가동해 바이트코드를 기계어로 변환
- 핫스팟은 프로파일링 정보를 보관하지않고 실행마다 다시 만듭니다.

### 9.2.3 AOT 컴파일 VS JIT 컴파일
- 핫스팟은 새로운 프로세서기능을 활용할 수 있고 다시 컴파일 하지 않아도 된다.
- JIT 컴파일러도 향상되고 핫스팟 VM도 향상된다.


### 9.3 핫스팟 JIT 기초
- 핫스팟의 기본 컴파일 단위는 전체 메서드
- 한 메서드에 해당하는 바이트 코드는 네이티브 코드로 컴파일됩니다.
- 핫스팟은 주로 KLASSS 메타 데이터 구조체에 있는 vtable을 이용해 JIT 컴파일을 구현합니다.
- 핫스팟은 C++ 애플리케이션 입니다.
- JIT 컴파일 서브시스템을 구성하는 스레드는 핫스팟 내부에서 가장 중요한 스레드들입니다.
- 낙점된 메서드는 컴파일 스레드에 올려놓고 백그라운드에서 컴파일합니다.
- 최적화된 기계어가 생성되면 VTABLE은 새로 컴파일된 코드를 가리키게 됩니다. (포인터 스위즐링)

### 9.3.2 JIT 컴파일 로깅
- 컴파일 이벤트 로그가 표준 출력 스트림에 생성되므로 성능 엔지니어는 이 로그를 보고 어떤 메서드가 컴파일 되고 있는지 파악 가능
- `-XX:+PrintCompilation`
- n 은 네이티브 메서드, s는 동기화 메서드, ! 은 예외 핸들러를 지닌 메서드
- `-XX:+LogCompilation`은 진단용 옵션 `-XX:+UnlockDiagnosticVMOptions` 로 바이트 코드를 어떻게 네이티브 코드로 최적화 했는지
  - 큐잉은 어떻게 처리했는지 xml 태그형태로 담은 로그파일로 출력하라는 지시입니다.
### 9.3.3 핫스팟 내부의 컴파일러
- C1, C2라는 두 JIT 컴파일러가 있음
- C2 실행시간 긴 서버 애플리케이션 대상
- 핫스팟은 기준없이 최대한 성능 맞게 변화
- 메서드 호출 횟수에 따라 컴파일이 트리거링됨
- 호출 횟수가 특정 한계치에 다다르면 VM이 알림 받고 해당메서드를 컴파일 큐에 넣음
- SAA 같은 FINAL로 만드는 기법을 사용함

### 9.3.4 핫스팟의 단계별 컴파일
- 컴파일모드 지원합니다. 하지만 디폴트라서 건드릴 이유 없음

## 9.4 코드 캐시
- JIT 컴파일드 코드는 코드 캐시라는 메모리 영역에 저장
- VM 시작시 코드 캐시는 설정된 값으로 최대 크기가 고정 확장 불가능
- 코드 캐시가 차면 JIT 컴파일 안됨, 컴파일 되지않는 코드는 인터프리터에서 실행
- 최대로 성능 못냄
- 코드 캐시는 스위퍼로 재활용하고 프리블록연결리스트를 담은 힙으로 구현됩니다.
- 네이티브 코드를 제거할 때는 역최적화(추측 틀림)
- 다른 컴파일 버전으로 교체될때
- 메서드를 지닌 클래스가 언로딩 될때 제거됩니다.

### 9.4.1 단편화
- 코드 캐시는 단편화 되기 쉽다. (JAVA 8)

### 9.5 간단한 JIT 튜닝법
- 컴파일을 원하는 메서드에게 리소스 먼저 다쓴다
- 캐시 크기를 늘리면 컴파일드 메서드 규모가 유의미한 방향으로 커지는지 확인 필요
- 주요 트랜잭션 경로상 위치한 주요 메서드 모두 컴파일 되는지 확인
- 트랜잭션 메서드드들이 컴파일 로그에 뜨는 지 확인

### 9.6 마치며
- JIT 컴파일드 코드의 동작이 인터프리터 동작보다 더 중요하다
- 다음장은 JIT 컴파일 이론을 체크해봅시다.
