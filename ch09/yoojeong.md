
### AOT vs JIT

- AOT 컴파일
  - AOT의 목표는 프로그램을 실행할 플랫폼과 프로세서 아키텍처에 딱 맞는 실행 코드를 얻는 것
  - 대부분의 실행 코드는 자신이 어떤 플랫폼에서 실행될지 모르기에 AOT 컴파일한 바이너리는 CPU 기능을 최대한 활용하지 못하는 경우가 많다.
- JIT 컴파일
  - 프로그램의 런타임 실행 정보를 수집해서 어느 부분이 자주 쓰이고, 어느 부분을 최적화해야 가장 효과가 좋은지 프로파일을 만들어 결정(프로파일 기반 최적화 - PGO)
  - 바이트 코드를 네이티브 코드로 컴파일하는 비용은 런타임에 리소스를 소모하는 작업이므로 산발적으로 수행된다.
- AOT vs JIT
  - AOT 컴파일 시 성능 향상이 있지만 확장성이 떨어진다.
  - JIT 컴파일 방식은 새 릴리즈마다 jar 파일을 다시 컴파일하지 않아도 새로운 프로세서 기능에 관한 최적화 코드를 추가할 수 있다.

---

### 핫스팟 JIT

- 핫스팟은 멀티스레드 C++ 애플리케이션이기에 실행중인 자바 프로그램은 OS 관점에서 한 멀티스레드 애플리케이션이다.
- 핫스팟의 기본 컴파일 단위는 메서드이기에 한 메서드에 해당하는 바이트 코드는 한꺼번에 네이티브 코드로 컴파일된다.

![image](https://github.com/rachel5004/24-optimizing-java-2/assets/75432228/8452fe86-a76d-4eb3-837c-42b561a2f500)

### JIT 컴파일 로깅

- `-XX:+PrintCompilation` : 컴파일 이벤트 로그를 표준 출력 스트림으로 생성
- `-XX:LogCompilation` + `-XX:+UnlockDiagnosticVMOptions` : VM이 바이트코드를 네이티브 코드로 어떻게 최적화했는지, 큐잉은 어떻게 처리했는지 관련 정보를 로그 파일로 출력할 수 있다.

### 핫스팟 내부의 컴파일러

- c1 컴파일러(클라이언트 컴파일러)
- c2 컴파일러(서버 컴파일러)
- 두 컴파일러 모두 메소드 호출 횟수에 따라 컴파일이 트리거링되며, 호출 횟수가 한계치에 다다르면 VM이 알림을 받아 메소드를 컴파일 큐에 넣는다.

### 핫스팟의 단계별 컴파일

- 레벨0 : 인터프리터
- 레벨1 : C1 - 풀 최적화(프로파일링 없음)
- 레벨2 : C1 - 호출 카운터 + 백엣지 카운터
- 레벨3 : C1 - 풀 프로파일링
- 레벨4 : C2

### JIT 컴파일 튜닝법

- 캐시 크기를 늘리면 컴파일드 메서드 규모가 유의미한 방향으로 커지는가?
- 주요 트랜잭션 경로상에 위치한 주요 메서드가 모두 컴파일되고 있는가?


1. PrintCompilation 스위치를 켜고 애플리케이션을 실행한다.
2. 어느 메서드가 컴파일됐는지 기록한 로그를 수집한다.
3. ReservedCodeCacheSize를 통해 코드 캐시를 늘린다.
4. 애플리케이션을 재실행한다.
5. 확장된 캐시에서 컴파일드 메서드를 살펴본다.

---

# 코드 캐시

- JIT 컴파일된 코드는 코드캐시 메모리 영역에 저장된다.
- 코드 캐시의 크기는 고정되어 있고, 코드 캐시가 꽉차면 JIT 컴파일이 더이상 되지 않고 나머지 코드는 인터프리터에서만 실행된다.
- 네이티브 코드가 코드 캐시에서 제거되는 경우 
  - (추측성 최적화를 적용한 결과 틀린 것으로 판명되어) 역최적화 될 때
  - 다른 컴파일 버전으로 교체됐을 때 (단계별 컴파일)
  - 메소드를 지닌 클래스가 언로딩될 때
