# Ch9. JVM의 코드 실행

## 바이트 코드 해석
- JVM은 다음 세 공간에 주로 데이터를 담아 놓는다.
  1. 평가 스택: 메서드별로 하나씩 생성된다.
  2. 로컬 변수: 결과를 임시 저장.(특정 메서드별로 존재)
  3. 객체 힙: 메서드끼리, 스레드끼리 공유 

### JVM 바이트코드 개요
- JVM에서는 각 스택 머신 작업 코드(옵코드)는 1바이트로 나타내며(0~255개), 약  

## AOT와 JIT
### AOT 컴파일
- AOT 컴파일의 목표는 프로그램을 실행할 플랫폼과 프로세서 아키텍처에 딱 맞는 실행 코드를 얻는 것
- AOT 컴파일은 대부분 어떤 플랫폼에서 실행될 지 모르는 상태에서 실행코드를 생성하므로 프로세서 기능에 대한 보수적인 선택을 해야 한다. -> CPU 긴능을 최대한 활용하지 못한다.

### JIT 컴파일
- 런타임에 프로그램을 고도로 최적화된 기계어로 변환하는 기법
- JIT 서브 시스템은 실팽 프로그램과 VM 리소스를 공유하므로 프로파일링 및 최적화 비용 및 성능 기대치 사이의 균형 필요

## 핫스팟 JIT 기초
- 핫스팟의 기본 컴파일 단위는 전체 메서드
- 핫스팟은 한마디로 멀티 스레드 C++ 어플리케이션

### JIT 컴파일 로깅
- `-XX:+PrintComplication` : 성능 엔지니어가 반드시 기억해야 할 JVM 스위치
  - 컴파일 이벤트 로그가 표준 출력 스트림에 생성
  - 출력 형식: <vm 시작 이후 ms> <컴파일 메서드 순번>
    - n: 네이티브 메서드
    - s: 동기화 메서드
    - !: 예외 핸들러를 지닌 메서드
    - &: OSR을 통해 컴파일된 메서드
  
## 코드 캐시
- JIT 컴파일드 코드가 저장되는 메모리 영역
- 코드캐시는 설정된 값으로 최대 크기가 고정되므로 확장이 불가하며, 가득 차게 될 경우 더 이상 JIT 컴파일은 되지 않는다. -> 스위퍼라는 프로세스가 재활용 담다 

## 간단한 JIT 튜닝
- 단순 JIT 튜닝의 대원칙: 컴파일을 원하는 메서드에게 아낌없이 리소스를 베풀라
  1. 먼저, PrintComplication 스위치를 켜고 어플리케이션을 실행
  2. 어느 메서드가 컴파일 되었는지 기록된 로그 수집
  3. ReservedCodeCacheSize를 통해 코드 캐시를 늘린다.
  4. 어플리케이션을 재실행한다.
  5. 확장된 캐시에서 컴파일된 메서드를 살펴본다.
- 관찰해야 할 두가지 사항
  - 캐시 크기를 늘리면 컴파일드 메서드 규모가 유의미한 반향으로 커지는가?
  - 주요 트랜잭션 경로상에 위치한 주요 메서드가 모두 컴파일되고 있는가?
