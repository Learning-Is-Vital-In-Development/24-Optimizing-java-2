## GC 로깅

GC 로그는 시스템이 내려간 원인의 단서를 찾는 ‘콜드 케이스’ 분석할때 매우 유용하다.

생성되는 로그량은 할당률, 사용 중인 수집기, 힙 크기(힙이 작으면 더 자주 GC하므로 로그가 더 자주 쌓임)에 따라 달라진다.

GC 로깅은 사실 오버헤드가 거의 없는 것이나 다름 없어 주요 JVM 프로세스는 항상 로깅을 켜놓아야 한다.

### GC 로그 vs JMX

VisualGC는 JVM 힙 상태를 실시간 표시한는 툴이다. 자바 관리 확장(JMX) 인터페이스를 통해 JVM 데이터를 수집한다. JMX가 GC에 영향을 주기 때문에 아래와 같은 사항을 숙지해야한다.

- GC 로그 데이터는 실제로 GC 이벤트가 발생해서 쌓이지만, JMX는 데이터를 샘플링 하여 얻는다.
- GC 로그 데이터는 캡처 영향도가 거의 없지만 JMX는 프록시 및 원격 메소드 호출 과정에서도 암묵적인 비용이 든다.
- GC 로그 데이터는 50여가지의 메모리와 관련된 성능 데이터가 있지만, JMX는 10가지도 안된다.
- JMX은 스트리밍된 데이터를 즉시 제공한다는 점에서 GC 로그보다 우리하지만, 요즘은 jClarity 센섬 같은 툴도 GC 로그 데이터를 스트리밍하는 API를 제공해서 별반 차이가 없다.

---

## 로그 파싱 툴

GC 로그 메세지는 정해진 언어나 VM 명세 표준 포멧이 따로없다. 로그에 어떤 메세지를 남길지 핫스팟 GC 개발팀 마임이라 포맷이 조금씩 다르다.

GC 로그 플래그가 추가되며 출력되는 로그도 엄청나게 복잡해졌다. 수동 GC 로그 파서를 쓰면 시스템에서 로깅이 끊어지는 사태가 곧 잘 발생하기때문에 반드시 툴을 사용하는 것이 좋다.

- 센섬
    
    jClarity사가 제작한 상용 메모리 분석기
    
    그 어느 툴보다도 다양한 GC 로그 설정을 지원한다.
    
    정확한 할당률, 조기 승격, 공격적인 할당, 유저 이탈, 메모리 누수 감지, 힙 용량 계획, VM에 대한 OS 간섭 등
    
- GCViwer
    
    GC 로그 파싱 및 그래프 출력 등 기본 기능을 갖춘 테스트톱 툴.
    
    오픈 소스여서 무료이지만 상용 툴에 비해 빈약한 기능을 감수해야한다.
    
    분석 기능은 없고 특정 GC 핫스팟 로그 포맷만 파싱 가능하다. 
    

---

## GC 기본 튜닝

GC 튜닝할때 다음을 기억하자

- GC가 성능 문제를 이르키는 근원인지 확인하는 행위는 져렴하다.
- UAT에서 GC 플래그를 켜는 것은 저렴한 행위이다.
- 메모리 프로파일러, 실행 프로파일러를 설정하는 작업은 결코 저렴하지 않다.

튜닝을 수행할 때 네가지 주요 인자를 면밀히 관찰/측정 해야한다.

- 할당
- 중단 민감도
- 처리율 추이
- 객체 수명

이 중 가장 중요한 요인은 할당이다.

현재 이벤트가 발생 중이라면, 성능 문제의 원인이 GC인지 아닌지 판단하는 것은 어렵지 않다. 먼저  vmstat 같은 툴로 고수준의 머신 지표를 체크하고 성능이 떨어진 시스템에서 다음을 확인한다.

- CPU 사용률이 100%에 가까운가
- 대부분의 시간(90%이상)이 유저 공간에서 소비되는가 (CG가 작업을 수행하는 동안 애플리케이션 코드 실행 지연)
- GC 로그가 쌓이고 있다면 현재 GC가 실행 중이라는 증거이다.

실시간 관측시 세가지 조건이 다 맞는다면 GC가 성능 이슈를 일으키고 있을 가능성이 크고 철저한 조사와 튜닝이 필요하다. GC를 튜닝하고 필요시 메모리 프로파일러를 활용한다.

### 할당

할당률 분석은 튜닝시 성능이 개선되었는지 여부를 판한다는 지표로 꼭 필요한 과정이다.

일정 시간 동안의 평균 할당률 수치가 1GB/s 이상으로 일정시간 지속된다면 가비지 수집기 튜닝만으로 해결할 수 없는 성능 문제가 터진것이다. 이 경우 **메모리 효율을 개선**하는 방법 밖에 없다.

초기 할당 전략은 아래와 같은 간순 영역에 집중하는 것이 좋다.

- 굳이 없어도 그만인, 사소한 객체 할당
- 박싱 비용
- 도메인 객체
    
    : 드물지만 도메인 객체가 메모리를 많이 차지하는 일이 있다.
    
    : 단순 힙 히스토리그램을 그려보면 불필요한 도메인 객체가 히스토그램의 상위권을 점유하면서 과하게 생성된 모습을 지켜볼 수 있다.
    
    → 덩치가 큰 배열(byte[], char[] 같은)이 빈 TLAB에 들어가지 않아 VM이 외부 영역에 위치한 에덴에 직접 객체 할당을 시도하고 이것도 실패할하면 힙 크기를 재조정하기를 시도하고, 최후의 방법으로 테뉴어드 영역에 객체를 직접할당하기 때문이다.
    
    → 핫스팟은 TLAB 및 큰 객체의 조기 승격에 관한 튜닝 플래그를 제공한다.
    
- 엄청난 양의 논JDK 프레임워크 객체

### 중단 시간

개발자는 중단 시간에 대한 인지 편향으로 종종 시달린다. 

중단 시간 튜닝 시 유용한 휴리스틱이 있으나, 어디까지 경험적 가이드일 뿐 정확한 규칙은 아니다. 

애플리케이션 응답 요건에 따라 허용가능한 중단 시간을 세 대역으로 나눠 표현하는 방식이다.

- 1초 이상 걸려도 괜찮다.
- 100밀리초 이상 1초 이하 정도는 괜찮다.
- 100밀리초까지는 괜찮다.

→ 중단 민감도를 힙 크기와 연관 지어 어느 수집기가 가장 적절한지 가늠할 수 있다.

### 수집기 스레드와 GC 루트

GC 루트 탐색 시간에 영향을 받는 요인

- 애플리케이션 스레드 개수
- 코드 캐시에 쌓인 컴파일드 코드량
- 힙 크기

→ 병렬화 정도에 따라 탐색 영향을 미친다는 것을 인지해야한다.

---

### Parallel GC 튜닝

가장 단순한 수집기인 만큼 튜닝도 제일 쉽다. 최소한의 튜닝만으로 충분하다. 

### CMS 튜닝

CMS 선능을 얻기위해서 여러가지 복잡성과 트레이드 오프가 있어 튜닝이 까다롭다.

- CMS처럼 중간 시간이 짧은 수집기에서 중단사건을 단축시키려하면 이렇다할 성능 향상도 못 본채, 모두가 튜닝하기 힘든 수집기로 고생할 수 있다.
- CMS 플래그의 가짓수가 방대하여 인지 함정에 빠질 수 있다.
- 그럼에도 개선해야 할 경우
    - 애플리케이션의 메모리 할당 속도가 회수 속도를 능가하면 결국 CMF가 일어난다. 해당 경우 실행 처리율이 50%나 떨어진다. → 호스트에 코어 수를 늘리거나 GC에 할당된 코어 수를 줄이는 해결방안을 모색한다.
    - 세이프 포인트에 예민한 저지연 애플리케이션의 경우 CMS가 일어날때의 세이프 포인트(초기마킹, 재마킹)에 의해 할당률이 심하기 튀는 현상을 방지해주기 위한 플래그를 실행한다.

### G1 튜닝

유저가 최대 힙 크기와 최대 GC 중단시간을 간단하게 설정하여 나머지는 수집기가 알아서 처리하게 하는 것이 G1 튜닝을 최종 목표

G1 수집기는 할당률에 뒤처지지 않는 한 계속 조금씩 압착하기때문에 CMF가 일어날 가능성이 전혀없습니다.

어떤 애플리케이션에서 할당률이 계속 높은 상태로 단명 객체가 생성되고 있다면 다음 튜닝을 고려해봄 직하다.

- 영세대를 크게 설정한다.
- 테뉴어드 한계치를 최대 15로 늘려 잡는다.
- 수용 가능한 최장 중단 시간 목표를 정한다.

→ 순수 단명 객체가 승격될 가능성이 줄어 올드 영역을 정리할 일도 줄어들 것이다.

---

## jHiccup (제이히컵)

HdrHistogram과 연관된 툴

JVM이 연속적으로 실행되지 못한 지점, 즉 히컵(딱국질)을 보여주는 계측 도구

히컵을 이르키는 가장 흔한 원인은 GC STW 중단이지만, OS나 플랫폼 관련 문제 때문에 발생하기도 한다.  따라서 jHiccup은 GC 튜닝에도 좋지만 초저지연 작업을 할때 유용한다.
