# 8. gc로깅, 모니터링, 튜닝, 툴
- 자바 성능 튜닝에서 gc 로깅과 모니터링을 다뤄보자

## 8.1 GC 로깅 개요
- GC 로그는 훌륭한 원천정보입니다.
- 콜드 케이스 분석(시스템 원인 분석을 할때도 유용), 후 분석 가능
- 모든 애플리케이션 두가지 설정해야함
  - GC 로그 생성
  - 특정 파일에 GC 로그 보관
- GC 로깅은 오버헤드가 없다.
- JVM 프로세스는 로깅을 켜놓아야한다.
### 8.1.1 GC 로깅 켜기
jvm을 사용하면 gc로깅은 무조건 켜야된다.
`-Xloggc:gc.log -XX:+PrintGCDetails -XX:PrintTenuringDistribution`
`-XX: +PrintGCTimeStamps -XX:+PrintGCDateStamps`
-Xloggc:gc.log -> gc 이벤트에 로깅할 파일을 정한다.
-XX:+PrintGCDetails -> gc 이벤트 세부 정보를 로깅한다.
-XX:PrintTenuringDistribution -> 툴링에 꼭 필요한 부가적인 GC이벤트 세부 정보를 추가한다.
    -> 메모리 할당 압박 효과, 조기승격 이벤트 계산시 필요한 기초 데이터 제공
-XX: +PrintGCTimeStamps -> GC 이벤트 발생 시간을 출력한다. (RUNTIME)
    -> GC 이벤트와 애플리케이션 이벤트 연관 관계 도출
-XX:+PrintGCDateStamps -> GC 이벤트 발생 시간을 출력한다. (시계시간)
    -> GC 이벤트와 JVM 이벤트를 연관 관계 도출

`-XX:+UseGCLogFileRotation -XX:+NumberOfGCLogFiles=<n> -XX:+GCLogFileSize=<size>`
-XX:+UseGCLogFileRotation -> 로그 순환 기능을 켠다.
-XX:+NumberOfGCLogFiles=<n> -> 보관 가능한 최대 로그 파일 개수를 설정한다.
-XX:+GCLogFileSize=<size> -> 순환 직전 각 파일의 최대 크기를 설정한다.


## 8.1.2 GC 로그 VS JMX
VisualGC는 JVM 힙 상태를 실시간으로 표시하는 툴입니다. JMX 인터페이스를 통해서 JVM 데이터를 수집합니다.
JMX는 GC에 영향을 줍니다.
1. GC 로그데이터는 실제로 가비지 수집 이벤트가 발생해서 쌓이는 반면 JMX는 데이터를 샘플링하여 얻습니다.
2. GC 로그 데이터는 캡처 영향도가 없지만, JMX는 프록시 및 원격 메서드 호출 관정에서도 암묵적인 비용이 듭니다.
3. GC 로그 데이터에는 자바 메모리 성능 데이터가 50가지 있지만 JMX는 10가지도 안됩니다.


### 8.1.3 JMX의 단점
1. 런타임을 샘플링하여 현재 상태를 업데이트 받음
2. 런타임에 있는 JMX 빈을 폴링한다.
-> 
- 문제는 가비지 수집 -> 각 수집 사이클 전후의 메모리 상태를 알 수 없어서 GC 데이터를 깊이 있게 정확하게 분석할 수 없다.
- 메모리압(할당률) 분석해야하는데 JMX는 데이터 수집 방식이 불가능하게한다.
- 추가적 단점들
  - 방화벽에 포트를 열어야한다. -> 부차 소켓 접속이 맺어질 수 있다.
  - 프록시 객체를 이용해 remove() 메서드 호출을 대행한다.
  - 자바 종료화(finalization) 에 의존한다 -> 가비지 수집기를 돌려서 객체 회수해야됨 -> 1시간마다 풀gc 발생 -> 부하 발생

### 8.1.4 GC 로그 데이터의 장점
- 처음 자바 gc를 개발한 분들은 GC 로깅을 JVM 구현체 디버깅 용도로 추가했습니다.
- 60개 가까운 GC플래그로 생성된 데이터 상당수가 성능 디버깅 목적으로 쓰이게 됐죠
- GC 로그 수집 및 분석은 튜닝 활동에서 절대 빠질 수 없다.
- GC 로그는 핫스팜 JVM 내부에서 논블로킹쓰기 메커니즘을 이용해 남깁니다. -> 성능에 영향 0


## 8.2 로그 파싱 툴
- 반드시 툴을 사용하세요

### 8.2.1 센섬
- 센섬은 jClarity 사가 제작한 상용 메모리 분석기 입니다. 마소 -> gc툴킷으로 오픈소스로 풀어버림 
- gc로그 파싱, 정보 추출, 자동 분석 기능 제공
  - 정확한 할당률
  - 조기 승격
  - 공격적인 할당
  - 유저 이탈
  - 메모리 누수 감지
  - 힙 크기 조정 및 용량 계획
  - vm에 대한 OS 간섭
  - 크기를 잘못잡은 메모리 풀

### 8.2.2 GCViewer
- 상용툴에 비해 빈약한 기능

## 8.3 GC 기본 튜닝
- GC는 언제 튜닝해야 할까?
- GC가 성능 문제를 일으키는 근원이라고 확인하거나 배제하는 해위는 저렴하다.
- UAT에서 GC 플래그를 켜는 것도 저렴하다.
- 메모리 프로파일러, 실행 프로파일러를 설정하는 작업은 저렴하지 않다.
- GC를 모니터링할때, 해당 사항들을 주시해야합니다.
  - 할당 (젤 중요)
  - 중단 민감도
  - 처리율 추이
  - 객체 수명

방법론
1. vmstat 같은 툴로 고수준의 머신 지표를 체크
2. CPU 사용률이 100%에 가까운가?
3. 시간(90%) 이상이 유저 공간에서 소비되는가?
4. GC로그가 쌓이고 있다면 현재 GC가 실행 중이라는 증거다.

세가지 조건이 다맞으면 GC일 확률이 높다.


### 8.3.1 할당이란?

- 할당률 분석은 가비지 수집기를 튜닝하면 성능이 개선될지 여부를 판단할 수있따.
- 이벤트 데이터를 활용하면 할당된 데이터양, 단위 수집 시간을 계산
- 평균 할당률을 산출 할 수 있다.

- 할당률 수치가 1GB/s 이상으로 지속한다면 십중팔구 가비지 수집기 튜닝만으로는 해결할 수 없는 문제가 있다.
- 애플리케이션 핵심부 할당 로직을 제거하는 리팩터링을 수행하여 메모리 효율을 개선해야한다.

효율 개선 방법 (Visual VM, jmap)
- 굳이 없어도 그만인, 사소한 객체 할당 (로그 디버깅 메시지) + json 직렬화, 역직렬화 용 자동 생성 코드 + ORM 코드
- 도메인 객체의 메모리 과도할당 문제
  - 단순 힙 히스토그램 그려보면 도메인 객체가 히스토그램 상위권을 점유하는 것을 볼 수 있습니다.
- 덩치 큰 배열만 곧바로 테뉴어드에 할당될 가능성이 큽니다.
- 핫스팟은 TLA 및 큰 객체의 조기 승격에 관한 튜닝 플래그를 제공합니다.
- 하지만 할당률은 테뉴어드로 승격되는 객체 수에 영향을 끼칩니다.
- 단명 객체는 장례를 치를 시간도 없이 테뉴어드로 잘못 승격될 가능성이 큽니다.
- 
- 조기 승격 관련 스위치 `-XX:MaxTenuringThreshold=<n>`
  - 한계치가 높을수록 진짜 장수한 객체를 더 많이 복사합니다.
  - 너무 낮으면 단명 객체가 승격되어 테뉴어드 메모리압을 가중 시킵니다.
- 테뉴어드로 승격되는 객체가 증가하고 풀 수집이 더 자주 발생합니다. -> 스위치를 함부러 변경하지 ㅏㅁ세요


### 8.3.2 중단 시간이란?
- 애플리케이션에서 100ms 정도의 중단 시간은 무시할만합니다.
- 풀스탑의 민감도에 따른 수집기 선택 
  - 1 초 이상 걸려도 괜찮다
    - PARALLEL/G1
  - 1초 100 ms초
    - PARALLEL/G1
  - 무조건 100ms 이하
    - CMS 돌려야함
    - 
### 8.3.3 수집기 스레드와 GC 루트
- GC 스레드 처럼 생각하려고 생각해봐라
- 루트 탐색 시간은 세가지 영향 요소가 있다.
  - 애플리케이션 스레드 개수
  - 코드 캐시에 쌓인 컴파일드 코드량
  - 힙 크기
- 객체 그래프가 복잡할 수록 마킹이 오래 걸릴 확률이 높다.
- 애플리케이션 스레드가 많아져도 스택 프레임을 더 많이 탐색해야한다.
- 세이프 포인트에 도달하는 시ㅏㄴ도 길어지는 등 gc 시간에 영향을 끼친다.

## 8.4 Parallel GC 튜닝
- 풀 STW
- GC 처리율이 높고 계산 비용이 싸다
- 부분 수집 X
- 중단 시간은 힙크기에 비례
- 가장 단순해서 튜닝이 젤 쉬움

## 8.5 CMS 튜닝
- CMS는 플래그의 가짓수가 방대하다.
- 튜닝을 하기 위해선 위험을 무릅써야한다.
- 처리율
  - GC 생기면 코어 절반이 GC에 할당됨
  - CMF가 생기기 직전에는 백투백 CMS 수집이 생김
  - 전체 애플리케이션 처리율 50%로 떨어짐
  - GC 할당 코어 줄이는 방법이 있지만 결국 CMF에 취약해짐
### 8.5.1 단편화로 인한 CMF
- 튜닝 분석에 필요한 데이터가 GC로그에만 존재하는 사례
- 프리리스트 통계치를 바탕으로  CMF를 예측할 수 있다.
- `-XX:PrintFLSStatistics=1`
- -> 메모리 청크의 크기 분포 짐작 가능 하고 로그를 분석하거나 센섬같은 툴을 쓰면 cmf 근접사실을 알아 낼 수 있습니다.

## 8.6 G1 튜닝
- 최대 힙크기와 최대 GC 중단 시간을 간간히 설정하면 나머지는 수집기가 하는것이 G1 튜닝의 최종 목표입니다.
- 하지만 변화가 많아서 베스트프랙티스를 가이드하긴 어렵다.
  - 영세대 설정
  - 테뉴어드 한계치 추가 
  - 수용가능한 최장 중단시간 목표 정해두기
